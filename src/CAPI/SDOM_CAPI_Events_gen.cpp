// Autogenerated implementation: do not edit
#include <SDOM/CAPI/SDOM_CAPI_Events.h>
#include <SDOM/SDOM_DataRegistry.hpp>
#include <string>
#include <vector>
#include <memory>
#include <cstring>
#include <cstdlib>
#include <SDOM/SDOM_EventType.hpp>
#include <SDOM/SDOM_Event.hpp>
#include <SDOM/SDOM_EventManager.hpp>
#include <SDOM/SDOM_Core.hpp>

// Use SDOM_StrDup()/SDOM_FreeString() declared in SDOM_CAPI_Common.h for string lifetime management.

struct SDOM_EventTypeHandle_ { SDOM::EventType* ptr = nullptr; char* name = nullptr; char* category = nullptr; char* doc = nullptr; bool owns = false; SDOM_EventTypeHandle_() = default; ~SDOM_EventTypeHandle_(){ if (name) SDOM_FreeString(name); if (category) SDOM_FreeString(category); if (doc) SDOM_FreeString(doc); } };

struct SDOM_EventHandle_ { SDOM::Event* ptr = nullptr; char* name = nullptr; char* payload_json = nullptr; SDOM_EventHandle_() = default; ~SDOM_EventHandle_(){ if (name) SDOM_FreeString(name); if (payload_json) SDOM_FreeString(payload_json); } };

// Dispatcher-based wrappers: these thin functions forward to the runtime
// dispatcher registered via SDOM::CAPI::registerCallable. They marshal
// arguments into CallArg, invoke the callable, then convert the
// CallResult back into the C API return/out parameters.

SDOM_EventTypeHandle SDOM_CreateEventType(const struct SDOM_EventTypeDesc *desc) {
    if (!desc || !desc->name) return nullptr;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)desc));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.CreateEventType", args);
        if (r.kind != SDOM::CAPI::CallArg::Kind::Ptr || !r.v.p) return nullptr;
        SDOM::EventType* et = reinterpret_cast<SDOM::EventType*>(r.v.p);
        auto h = new SDOM_EventTypeHandle_();
        h->ptr = et; h->owns = true;
        h->name = SDOM_StrDup(et->getName().c_str());
        h->category = SDOM_StrDup(et->getCategory().c_str());
        h->doc = SDOM_StrDup(et->getDoc().c_str());
        return reinterpret_cast<SDOM_EventTypeHandle>(h);
    } catch(...) { return nullptr; }
}

int SDOM_GetEventTypeDesc(SDOM_EventTypeHandle h, struct SDOM_EventTypeDesc *out) {
    if (!h || !out) return SDOM_CAPI_ERR_INVALID_ARG;
    SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h);
    if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr));
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)out));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.GetEventTypeDesc", args);
        if (r.kind == SDOM::CAPI::CallArg::Kind::Int) return static_cast<int>(r.v.i);
        // Fallback: fill out using the pointer
        SDOM::EventType* et = hh->ptr;
        out->name = hh->name ? hh->name : et->getName().c_str();
        out->id = static_cast<uint32_t>(et->getOrAssignId());
        out->category = hh->category ? hh->category : et->getCategory().c_str();
        out->doc = hh->doc ? hh->doc : et->getDoc().c_str();
        out->metadata_json = nullptr; out->user_data = nullptr;
        return SDOM_CAPI_OK;
    } catch(...) { return SDOM_CAPI_ERR_INTERNAL; }
}

int SDOM_UpdateEventType(SDOM_EventTypeHandle h, const struct SDOM_EventTypeDesc *desc) {
    if (!h || !desc) return SDOM_CAPI_ERR_INVALID_ARG;
    SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h);
    if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr));
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)desc));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.UpdateEventType", args);
        if (r.kind == SDOM::CAPI::CallArg::Kind::Int) return static_cast<int>(r.v.i);
        // fallback local update
        if (desc->doc) { if (hh->doc) SDOM_FreeString(hh->doc); hh->doc = SDOM_StrDup(desc->doc); hh->ptr->setDoc(std::string(desc->doc)); }
        if (desc->category) { if (hh->category) SDOM_FreeString(hh->category); hh->category = SDOM_StrDup(desc->category); hh->ptr->setCategory(std::string(desc->category)); }
        if (desc->id != 0) hh->ptr->setId(static_cast<SDOM::EventType::IdType>(desc->id));
        return SDOM_CAPI_OK;
    } catch(...) { return SDOM_CAPI_ERR_INTERNAL; }
}

void SDOM_DestroyEventType(SDOM_EventTypeHandle h) {
    if (!h) return;
    SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h);
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr));
        SDOM::CAPI::invokeCallable("Event.DestroyEventType", args);
    } catch(...) {}
    // caller still owns handle memory
    delete hh;
}

SDOM_EventTypeHandle SDOM_FindEventTypeByName(const char *name) {
    if (!name) return nullptr;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makeCString(name));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.FindEventTypeByName", args);
        if (r.kind != SDOM::CAPI::CallArg::Kind::Ptr || !r.v.p) return nullptr;
        SDOM::EventType* et = reinterpret_cast<SDOM::EventType*>(r.v.p);
        auto h = new SDOM_EventTypeHandle_();
        h->ptr = et;
        h->name = SDOM_StrDup(et->getName().c_str());
        h->category = SDOM_StrDup(et->getCategory().c_str());
        h->doc = SDOM_StrDup(et->getDoc().c_str());
        return reinterpret_cast<SDOM_EventTypeHandle>(h);
    } catch(...) { return nullptr; }
}

size_t SDOM_EnumEventTypes(size_t index, SDOM_EventTypeHandle *out) {
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makeUInt(static_cast<uint64_t>(index)));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.EnumEventTypes", args);
        if (r.kind != SDOM::CAPI::CallArg::Kind::Ptr || !r.v.p) return 0;
        SDOM::EventType* et = reinterpret_cast<SDOM::EventType*>(r.v.p);
        if (out) {
            auto h = new SDOM_EventTypeHandle_();
            h->ptr = et;
            h->name = SDOM_StrDup(et->getName().c_str());
            h->category = SDOM_StrDup(et->getCategory().c_str());
            h->doc = SDOM_StrDup(et->getDoc().c_str());
            *out = reinterpret_cast<SDOM_EventTypeHandle>(h);
        }
        return index + 1;
    } catch(...) { return 0; }
}

SDOM_EventHandle SDOM_CreateEvent(const struct SDOM_EventDesc *desc) {
    if (!desc) return nullptr;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)desc));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.CreateEvent", args);
        if (r.kind != SDOM::CAPI::CallArg::Kind::Ptr || !r.v.p) return nullptr;
        SDOM::Event* ev = reinterpret_cast<SDOM::Event*>(r.v.p);
        auto h = new SDOM_EventHandle_(); h->ptr = ev;
        try { h->name = SDOM_StrDup(ev->getType().getName().c_str()); } catch(...) { h->name = nullptr; }
        return reinterpret_cast<SDOM_EventHandle>(h);
    } catch(...) { return nullptr; }
}

int SDOM_GetEventDesc(SDOM_EventHandle h, struct SDOM_EventDesc *out) {
    if (!h || !out) return SDOM_CAPI_ERR_INVALID_ARG;
    SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h);
    if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr));
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)out));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.GetEventDesc", args);
        if (r.kind == SDOM::CAPI::CallArg::Kind::Int) return static_cast<int>(r.v.i);
        SDOM::Event* ev = hh->ptr; out->type_id = static_cast<uint32_t>(ev->getType().getOrAssignId()); out->name = hh->name ? hh->name : ev->getTypeName().c_str(); out->payload_json = nullptr; out->user_data = nullptr; return SDOM_CAPI_OK;
    } catch(...) { return SDOM_CAPI_ERR_INTERNAL; }
}

int SDOM_UpdateEvent(SDOM_EventHandle h, const SDOM_EventDesc *desc) {
    if (!h || !desc) return SDOM_CAPI_ERR_INVALID_ARG;
    SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h);
    if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr));
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)desc));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.UpdateEvent", args);
        if (r.kind == SDOM::CAPI::CallArg::Kind::Int) return static_cast<int>(r.v.i);
        return SDOM_CAPI_OK;
    } catch(...) { return SDOM_CAPI_ERR_INTERNAL; }
}

void SDOM_DestroyEvent(SDOM_EventHandle h) {
    if (!h) return;
    SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h);
    try { std::vector<SDOM::CAPI::CallArg> args; args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr)); SDOM::CAPI::invokeCallable("Event.DestroyEvent", args); } catch(...) {}
    if (hh->ptr) delete hh->ptr;
    delete hh;
}

int SDOM_SendEvent(SDOM_EventHandle h) {
    if (!h) return SDOM_CAPI_ERR_INVALID_ARG;
    SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h);
    if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG;
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        args.push_back(SDOM::CAPI::CallArg::makePtr((void*)hh->ptr));
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.SendEvent", args);
        if (r.kind == SDOM::CAPI::CallArg::Kind::Int) return static_cast<int>(r.v.i);
        return SDOM_CAPI_OK;
    } catch(...) { return SDOM_CAPI_ERR_INTERNAL; }
}

int SDOM_GetEventQueueSize(void) {
    try {
        std::vector<SDOM::CAPI::CallArg> args;
        SDOM::CAPI::CallResult r = SDOM::CAPI::invokeCallable("Event.GetEventQueueSize", args);
        if (r.kind == SDOM::CAPI::CallArg::Kind::Int) return static_cast<int>(r.v.i);
        return SDOM::Core::getInstance().getEventManager().getEventQueueSize();
    } catch(...) { return -1; }
}
