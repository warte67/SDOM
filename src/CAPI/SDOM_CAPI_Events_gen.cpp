// Autogenerated implementation: do not edit
#include <SDOM/CAPI/SDOM_CAPI_Events.h>
#include <string>
#include <vector>
#include <memory>
#include <cstring>
#include <cstdlib>
#include <sol/sol.hpp>
#include <SDOM/SDOM_EventType.hpp>
#include <SDOM/SDOM_Event.hpp>
#include <SDOM/SDOM_EventManager.hpp>
#include <SDOM/SDOM_Core.hpp>

static inline char* sdom_dupstr(const char* s) { if (!s) return nullptr; size_t n = strlen(s) + 1; char* p = (char*)malloc(n); if (!p) return nullptr; memcpy(p, s, n); return p; }

struct SDOM_EventTypeHandle_ { SDOM::EventType* ptr = nullptr; char* name = nullptr; char* category = nullptr; char* doc = nullptr; bool owns = false; SDOM_EventTypeHandle_() = default; ~SDOM_EventTypeHandle_(){ if (name) free(name); if (category) free(category); if (doc) free(doc); } };

struct SDOM_EventHandle_ { SDOM::Event* ptr = nullptr; char* name = nullptr; char* payload_json = nullptr; SDOM_EventHandle_() = default; ~SDOM_EventHandle_(){ if (name) free(name); if (payload_json) free(payload_json); } };

#define SDOM_CAPI_OK 0
#define SDOM_CAPI_ERR_INVALID -1
#define SDOM_CAPI_ERR_NOT_FOUND -2
#define SDOM_CAPI_ERR_INTERNAL -3

SDOM_EventTypeHandle SDOM_CreateEventType(const struct SDOM_EventTypeDesc *desc) { if (!desc || !desc->name) return nullptr; try { SDOM::EventType* et = nullptr; const std::string name = desc->name ? std::string(desc->name) : std::string(); const char* cat = desc->category; const char* doc = desc->doc; if (cat) { const std::string category = std::string(cat); const std::string docstr = doc ? std::string(doc) : std::string(); et = new SDOM::EventType(name, category, docstr); } else if (doc) { et = new SDOM::EventType(name); et->setDoc(std::string(doc)); } else { et = new SDOM::EventType(name); } auto h = new SDOM_EventTypeHandle_(); h->ptr = et; h->owns = true; h->name = sdom_dupstr(et->getName().c_str()); h->category = sdom_dupstr(et->getCategory().c_str()); h->doc = sdom_dupstr(et->getDoc().c_str()); return reinterpret_cast<SDOM_EventTypeHandle>(h); } catch(...) { return nullptr; } }

int SDOM_GetEventTypeDesc(SDOM_EventTypeHandle h, struct SDOM_EventTypeDesc *out) { if (!h || !out) return SDOM_CAPI_ERR_INVALID; SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID; SDOM::EventType* et = hh->ptr; out->name = hh->name ? hh->name : et->getName().c_str(); out->id = static_cast<uint32_t>(et->getOrAssignId()); out->category = hh->category ? hh->category : et->getCategory().c_str(); out->doc = hh->doc ? hh->doc : et->getDoc().c_str(); out->metadata_json = nullptr; out->user_data = nullptr; return SDOM_CAPI_OK; }

int SDOM_UpdateEventType(SDOM_EventTypeHandle h, const struct SDOM_EventTypeDesc *desc) { if (!h || !desc) return SDOM_CAPI_ERR_INVALID; SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID; SDOM::EventType* et = hh->ptr; if (desc->doc) et->setDoc(std::string(desc->doc)); if (desc->category) et->setCategory(std::string(desc->category)); if (desc->id != 0) et->setId(static_cast<SDOM::EventType::IdType>(desc->id)); if (desc->doc) { if (hh->doc) free(hh->doc); hh->doc = sdom_dupstr(desc->doc); } if (desc->category) { if (hh->category) free(hh->category); hh->category = sdom_dupstr(desc->category); } return SDOM_CAPI_OK; }

void SDOM_DestroyEventType(SDOM_EventTypeHandle h) { if (!h) return; SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h); delete hh; }

SDOM_EventTypeHandle SDOM_FindEventTypeByName(const char *name) { if (!name) return nullptr; SDOM::EventType* et = SDOM::EventType::fromName(std::string(name)); if (!et) return nullptr; auto h = new SDOM_EventTypeHandle_(); h->ptr = et; h->name = sdom_dupstr(et->getName().c_str()); h->category = sdom_dupstr(et->getCategory().c_str()); h->doc = sdom_dupstr(et->getDoc().c_str()); return reinterpret_cast<SDOM_EventTypeHandle>(h); }

size_t SDOM_EnumEventTypes(size_t index, SDOM_EventTypeHandle *out) { auto all = SDOM::EventType::getAll(); if (index >= all.size()) return 0; if (out) { SDOM::EventType* et = all[index]; auto h = new SDOM_EventTypeHandle_(); h->ptr = et; h->name = sdom_dupstr(et->getName().c_str()); h->category = sdom_dupstr(et->getCategory().c_str()); h->doc = sdom_dupstr(et->getDoc().c_str()); *out = reinterpret_cast<SDOM_EventTypeHandle>(h); } return index + 1; }

SDOM_EventHandle SDOM_CreateEvent(const struct SDOM_EventDesc *desc) { if (!desc) return nullptr; SDOM::EventType* et = nullptr; if (desc->type_id != 0) { et = SDOM::EventType::fromId(static_cast<SDOM::EventType::IdType>(desc->type_id)); } if (!et) { if (desc->name) et = SDOM::EventType::fromName(std::string(desc->name)); } SDOM::Event* ev = nullptr; if (et) { ev = new SDOM::Event(*et); } else { ev = new SDOM::Event(SDOM::EventType("None")); } auto h = new SDOM_EventHandle_(); h->ptr = ev; try { h->name = sdom_dupstr(ev->getType().getName().c_str()); } catch(...) { h->name = nullptr; } return reinterpret_cast<SDOM_EventHandle>(h); }

int SDOM_GetEventDesc(SDOM_EventHandle h, struct SDOM_EventDesc *out) { if (!h || !out) return SDOM_CAPI_ERR_INVALID; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID; SDOM::Event* ev = hh->ptr; out->type_id = static_cast<uint32_t>(ev->getType().getOrAssignId()); out->name = hh->name ? hh->name : ev->getTypeName().c_str(); out->payload_json = nullptr; out->user_data = nullptr; return SDOM_CAPI_OK; }

int SDOM_UpdateEvent(SDOM_EventHandle h, const SDOM_EventDesc *desc) { if (!h || !desc) return SDOM_CAPI_ERR_INVALID; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID; (void)hh; (void)desc; return SDOM_CAPI_OK; }

void SDOM_DestroyEvent(SDOM_EventHandle h) { if (!h) return; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (hh->ptr) delete hh->ptr; delete hh; }

int SDOM_SendEvent(SDOM_EventHandle h) { if (!h) return SDOM_CAPI_ERR_INVALID; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID; try { auto evCopy = std::make_unique<SDOM::Event>(*hh->ptr); SDOM::Core::getInstance().getEventManager().addEvent(std::move(evCopy)); return SDOM_CAPI_OK; } catch(...) { return SDOM_CAPI_ERR_INTERNAL; } }
