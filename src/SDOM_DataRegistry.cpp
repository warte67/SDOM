#include <SDOM/SDOM_DataRegistry.hpp>
#include <SDOM/SDOM_IBindingGenerator.hpp>
#include <filesystem>
#include <fstream>
#include <sstream>

// Define destructor out-of-line so that unique_ptr<IBindingGenerator> has a
// complete type available at destruction time (IBindingGenerator is included
// above). This avoids applying sizeof to an incomplete type in headers.
SDOM::DataRegistry::~DataRegistry() = default;

// Define the private Impl type used to hide generator storage from headers.
struct SDOM::DataRegistry::Impl {
    std::vector<std::unique_ptr<IBindingGenerator>> generators;
};

SDOM::DataRegistry::DataRegistry()
    : impl_(std::make_unique<Impl>())
{}

namespace SDOM {

DataRegistry& DataRegistry::instance()
{
    static DataRegistry s;
    return s;
}

bool DataRegistry::registerType(const TypeInfo& info)
{
    std::scoped_lock lk(mutex_);
    auto it = types_.find(info.name);
    if (it != types_.end()) return false;
    types_.emplace(info.name, info);
    return true;
}

bool DataRegistry::registerDataType(const TypeInfo& info)
{
    // Same behavior as registerType; preserve existing semantics.
    return registerType(info);
}

// Non-template overloads ----------------------------------------------------
void DataRegistry::registerFunction(const std::string& typeName, const FunctionInfo& meta)
{
    std::scoped_lock lk(mutex_);
    types_[typeName].functions.push_back(meta);
}

void DataRegistry::registerProperty(const std::string& typeName, const PropertyInfo& meta)
{
    std::scoped_lock lk(mutex_);
    types_[typeName].properties.push_back(meta);
}

const TypeInfo* DataRegistry::lookupType(const std::string& name) const
{
    std::scoped_lock lk(mutex_);
    auto it = types_.find(name);
    if (it == types_.end()) return nullptr;
    return &it->second;
}

std::vector<std::string> DataRegistry::listTypes() const
{
    std::vector<std::string> out;
    std::scoped_lock lk(mutex_);
    out.reserve(types_.size());
    for (const auto& kv : types_) out.push_back(kv.first);
    return out;
}

// Generator integration (phase-2): addGenerator is currently a no-op until
// the IBindingGenerator interface is implemented. This avoids compiling
// against an incomplete type while the generator abstraction is designed.

bool DataRegistry::generateBindings(const std::string& outputDir)
{
    // Copy the registry state and generator pointers while holding the lock,
    // then release the lock before invoking generators. Generators commonly
    // call back into the registry (e.g. listTypes()) which would deadlock if
    // we held the mutex while calling them.
    std::vector<TypeInfo> types_copy;
    std::vector<IBindingGenerator*> gens;
    {
        std::scoped_lock lk(mutex_);
        types_copy.reserve(types_.size());
        for (const auto& kv : types_) types_copy.push_back(kv.second);
        if (impl_) {
            for (auto& gptr : impl_->generators) if (gptr) gens.push_back(gptr.get());
        }
    }

    try {
        std::filesystem::create_directories(outputDir);
        // For now emit a single simple header with object prototypes
        std::ostringstream out;
        out << "/* Generated by SDOM DataRegistry */\n";
        out << "#ifndef SDOM_CAPI_OBJECTS_H\n#define SDOM_CAPI_OBJECTS_H\n\n";
        out << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";

        for (const auto& ti : types_copy) {
            // Keep the original type name in the comment, but sanitize for C identifiers
            out << "/* Type: " << ti.name << " */\n";
            std::string id = ti.name;
            for (char &c : id) if (c == ':' || c == ' ' || c == '-') c = '_';
            out << "typedef struct SDOM_" << id << " SDOM_" << id << ";\n\n";
            // properties
            for (const auto& p : ti.properties) {
                // getter
                out << "// property: " << p.name << "\n";
                out << "const char* SDOM_" << id << "_get" << p.name << "(const SDOM_" << id << "*);\n";
                if (!p.read_only) {
                    out << "void SDOM_" << id << "_set" << p.name << "(SDOM_" << id << "*, const char*);\n";
                }
            }
            // functions
            for (const auto& f : ti.functions) {
                out << "void SDOM_" << id << "_" << f.name << "(SDOM_" << id << "*);\n";
            }
            out << "\n";
        }

        out << "#ifdef __cplusplus\n}\n#endif\n\n#define SDOM_CAPI_VERSION \"generated\"\n\n#endif // SDOM_CAPI_OBJECTS_H\n";

        std::filesystem::path p = outputDir;
        p /= "sdom_capi_objects.h";
        std::ofstream fh(p);
        fh << out.str();
        fh.close();
    } catch (...) {
        return false;
    }

    // Invoke any registered binding generators (phase-2) without holding the
    // registry mutex to avoid deadlocks if generators call back into the
    // registry. Pass a lightweight snapshot rather than the live registry so
    // generators can't accidentally re-enter the registry's locks.
    DataRegistrySnapshot snapshot;
    snapshot.types = std::move(types_copy);
    for (auto gen : gens) {
        try {
            if (gen) gen->generate(snapshot, outputDir);
        } catch (...) {
            // swallow generator errors; the basic emitter already succeeded
        }
    }

    return true;
}

void DataRegistry::addGenerator(std::unique_ptr<IBindingGenerator> generator)
{
    std::scoped_lock lk(mutex_);
    if (!impl_) impl_ = std::make_unique<Impl>();
    if (generator) impl_->generators.push_back(std::move(generator));
}

} // namespace SDOM
