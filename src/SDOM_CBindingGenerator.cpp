#include <SDOM/SDOM_CBindingGenerator.hpp>
#include <SDOM/SDOM_DataRegistry.hpp>
#include <filesystem>
#include <fstream>
#include <iomanip>

#include <SDOM/SDOM_Version.hpp>
#include <SDOM/SDOM_EventType.hpp>
#include <unordered_map>

// Local generator-only event id registry to avoid linking the full runtime
[[maybe_unused]] static std::unordered_map<std::string, uint32_t> s_local_event_id_map;
[[maybe_unused]] static uint32_t s_local_next_event_id = 1;

using namespace SDOM;
namespace fs = std::filesystem;

static std::string join_path(const std::string &a, const std::string &b) {
    fs::path p(a);
    p /= b;
    return p.string();
}

bool CBindingGenerator::generate(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Create output dir if missing
    std::error_code ec;
    fs::create_directories(outputDir, ec);
    if (ec) return false;

    const std::string filename = join_path(outputDir, "sdom_capi_objects_generated.h");
    std::ofstream ofs(filename, std::ios::trunc);
    if (!ofs) return false;

    // Emit version macros so consumers can quickly check the C API version
    ofs << "/* Generated by SDOM CBindingGenerator */\n";
    ofs << "#ifndef SDOM_CAPI_OBJECTS_GENERATED_H\n";
    ofs << "#define SDOM_CAPI_OBJECTS_GENERATED_H\n\n";

    // Version macros taken from SDOM build
    ofs << "#define SDOM_CAPI_GENERATED_MAJOR " << SDOM_VERSION_MAJOR << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_MINOR " << SDOM_VERSION_MINOR << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_PATCH " << SDOM_VERSION_PATCH << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_VERSION_STRING \"" << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH << "\"\n\n";

    ofs << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";

    // Emit a typedef for a generic handle type
    ofs << "typedef void* sdom_handle_t;\n\n";

    auto sanitize_id = [](std::string s) {
        // collapse C++ scope separators and common separators into single '_'
        // replace "::" with "_"
        for (;;) {
            size_t pos = s.find("::");
            if (pos == std::string::npos) break;
            s.replace(pos, 2, "_");
        }
        for (char &c : s) if (c == ' ' || c == '-' || c == ':') c = '_';
        // collapse repeated underscores
        std::string out;
        out.reserve(s.size());
        for (char ch : s) {
            if (ch == '_' && !out.empty() && out.back() == '_') continue;
            out.push_back(ch);
        }
        // trim leading/trailing underscores
        if (!out.empty() && out.front() == '_') out.erase(out.begin());
        if (!out.empty() && out.back() == '_') out.pop_back();
        return out;
    };

    // No per-type creation/destruction functions are emitted here.
    // The events header will declare compact descriptor structs and a
    // small set of generic handle-based APIs instead of many per-property
    // accessor functions. This keeps the C API stable and language-friendly.

    // Emit any explicit C function prototypes registered in the DataRegistry
    // If a FunctionInfo includes a `c_signature`, prefer that. Otherwise
    // emit a simple fallback prototype using the function name.
    ofs << "/* Exported C API function prototypes (generated) */\n";
    for (const auto &ti : snapshot.types) {
        for (const auto &fi : ti.functions) {
            if (!fi.exported) continue;
            // Prefer an explicit C signature when provided
            if (!fi.c_signature.empty()) {
                ofs << fi.c_signature << "\n";
                continue;
            }

            // If this function was registered with a C function pointer,
            // emit an appropriate extern "C" prototype. Prefer an
            // explicit c_name when present; otherwise synthesize one.
            if (fi.callable_kind == SDOM::FunctionInfo::CallableKind::CFunctionPtr) {
                std::string ret = fi.return_type.empty() ? "void" : fi.return_type;
                std::string params;
                if (fi.param_types.empty()) {
                    params = "void";
                } else {
                    for (size_t i = 0; i < fi.param_types.size(); ++i) {
                        if (i) params += ", ";
                        params += fi.param_types[i];
                    }
                }
                // Default C name: SDOM_<Type>_<FunctionName>
                std::string tclean = sanitize_id(ti.name);
                std::string cname = fi.c_name.empty() ? (std::string("SDOM_") + tclean + "_" + fi.name) : fi.c_name;
                ofs << "extern \"C\" " << ret << " " << cname << "(" << params << ");\n";
                continue;
            }

            // If function was registered as a Lua-ref, emit a prototype
            // guarded by SDOM_ENABLE_LUA_BINDINGS so users can opt-in to
            // generated Lua dispatch wrappers. We don't generate marshalling
            // code here â€” runtime must supply a dispatcher to call the ref.
            if (fi.callable_kind == SDOM::FunctionInfo::CallableKind::LuaRef) {
                std::string ret = fi.return_type.empty() ? "void" : fi.return_type;
                std::string params = fi.param_types.empty() ? std::string("void") : std::string();
                for (size_t i = 0; i < fi.param_types.size(); ++i) {
                    if (i) params += ", ";
                    params += fi.param_types[i];
                }
                std::string tclean = sanitize_id(ti.name);
                std::string cname = fi.c_name.empty() ? (std::string("SDOM_Lua_") + tclean + "_" + fi.name) : fi.c_name;
                ofs << "#ifdef SDOM_ENABLE_LUA_BINDINGS\n";
                ofs << "extern \"C\" " << ret << " " << cname << "(" << params << ");\n";
                ofs << "#endif // SDOM_ENABLE_LUA_BINDINGS\n";
                continue;
            }

            // Fallback: emit a generic extern declaration using the c_name or function name
            if (!fi.c_name.empty()) {
                ofs << "/* fallback */ extern \"C\" void " << fi.c_name << "(void);\n";
            } else {
                std::string tclean = sanitize_id(ti.name);
                ofs << "/* fallback */ extern \"C\" void SDOM_" << tclean << "_" << fi.name << "(void);\n";
            }
        }
    }

    ofs << "#ifdef __cplusplus\n}\n#endif\n\n";
    ofs << "#endif // SDOM_CAPI_OBJECTS_GENERATED_H\n";

    ofs.close();

    // Also write a repository copy of `sdom_capi_objects_generated.h` so that
    // consumers who include headers from the repo (rather than the build
    // output) can find the required objects header. Place it under
    // `include/SDOM/CAPI/` to keep C API headers together.
    try {
        // Find repository root (a parent directory containing CMakeLists.txt)
        std::filesystem::path cwd = std::filesystem::current_path();
        std::filesystem::path repo_root;
        for (auto p = cwd; ; p = p.parent_path()) {
            if (p == p.parent_path()) break; // reached filesystem root
            if (std::filesystem::exists(p / "CMakeLists.txt")) { repo_root = p; break; }
        }
        if (!repo_root.empty()) {
            std::filesystem::path repo_out_dir = repo_root / "include" / "SDOM" / "CAPI";
            std::error_code ec;
            std::filesystem::create_directories(repo_out_dir, ec);
            if (!ec) {
                std::filesystem::path repo_out = repo_out_dir / "sdom_capi_objects_generated.h";
                std::ifstream inf(filename);
                if (inf) {
                    std::ofstream ofs_repo(repo_out.string(), std::ios::trunc);
                    if (ofs_repo) {
                        ofs_repo << inf.rdbuf();
                        ofs_repo.close();
                        std::cout << "[CBindingGenerator] copied objects header to " << repo_out.string() << std::endl;
                    }
                }
            }
        }
    } catch(...) {}

    // Also write a marker file and a simple .version file for quick parsing
    std::ofstream marker(join_path(outputDir, ".c_binding_generator_marker"));
    if (marker) marker << "generated" << std::endl;

    // version file
    std::ostringstream ver;
    ver << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH;
    std::ofstream vfh(join_path(outputDir, "sdom_capi_objects_generated.version"));
    if (vfh) vfh << ver.str() << std::endl;

    // Emit event-specific bindings/header
    try {
        generateEventBindings(snapshot, outputDir);
    } catch(...) {}
    try {
        emitCAPIEventsHeader(snapshot, outputDir);
    } catch(...) {}

    return true;
}

bool CBindingGenerator::generateEventBindings(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Emit a small file that lists types that look like Event or EventType
    const std::string filename = join_path(outputDir, "sdom_event_bindings_generated.h");
    std::ofstream ofs(filename, std::ios::trunc);
    if (!ofs) return false;

    ofs << "/* Generated Event bindings (stub) */\n";
    ofs << "#pragma once\n\n";
    ofs << "// Types discovered in registry snapshot:\n";
    for (const auto &ti : snapshot.types) {
        if (ti.name.find("Event") != std::string::npos) {
            ofs << "// " << ti.name << "\n";
        }
    }
    ofs.close();
    std::cout << "[CBindingGenerator] wrote " << filename << std::endl;
    return true;
}

bool CBindingGenerator::emitCAPIEventsHeader(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Build a deterministic list of EventType entries from the registry
    // Map event short-name -> docstring (if present)
    std::unordered_map<std::string, std::string> event_docs;
    std::vector<std::string> events;
    for (const auto &ti : snapshot.types) {
        // We registered per-instance EventType entries as "EventType::<name>"
        if (ti.name.rfind("EventType::", 0) == 0) {
            std::string shortname = ti.name.substr(strlen("EventType::"));
            events.push_back(shortname);
            if (!ti.doc.empty()) event_docs[shortname] = ti.doc;
        }
    }

    (void)event_docs; // silence unused when debug removed

    // Build ordered list of events, preferring runtime-assigned EventType ids.
    // To avoid fallback ids colliding or interleaving with runtime ids we
    // first collect any runtime ids, pick a fallback start value after the
    // maximum runtime id, then assign fallback ids sequentially.
    struct EventEntry { std::string name; uint32_t id; std::string doc; };
    std::vector<EventEntry> ordered;

    // First pass: collect runtime ids where available and remember which
    // names need fallback ids.
    std::vector<std::string> need_fallback;
    uint32_t max_runtime_id = 0;
    for (const auto &n : events) {
        try {
            SDOM::EventType* et = SDOM::EventType::fromName(n);
            if (et) {
                uint32_t rid = static_cast<uint32_t>(et->getOrAssignId());
                EventEntry e{n, rid, ""};
                // Prefer runtime-provided docstring when available; fall back
                // to snapshot-provided docs if runtime doc is empty.
                try {
                    std::string rd = et->getDoc();
                    if (!rd.empty()) e.doc = rd;
                } catch(...) {}
                if (e.doc.empty()) {
                    auto it = event_docs.find(n);
                    if (it != event_docs.end()) e.doc = it->second;
                }
                ordered.push_back(std::move(e));
                if (rid > max_runtime_id) max_runtime_id = rid;
                continue;
            }
        } catch(...) {
            // ignore and mark for fallback
        }
        need_fallback.push_back(n);
    }

    // Start fallback ids after the max runtime id to keep runtime-assigned
    // ids ordered before any generated fallbacks.
    uint32_t fallback_next_id = (max_runtime_id >= 1) ? (max_runtime_id + 1) : 1u;
    for (const auto &n : need_fallback) {
        EventEntry e{n, fallback_next_id++, ""};
        auto it = event_docs.find(n);
        if (it != event_docs.end()) e.doc = it->second;
        ordered.push_back(std::move(e));
    }

    // Sort by numeric id (stable to preserve the earlier order for ties).
    std::stable_sort(ordered.begin(), ordered.end(), [](const EventEntry &a, const EventEntry &b){
        return a.id < b.id;
    });

    // Build name -> category map from the snapshot (fallback to "Uncategorized")
    std::unordered_map<std::string, std::string> name_to_category;
    for (const auto &ti : snapshot.types) {
        if (ti.name.rfind("EventType::", 0) == 0) {
            std::string shortname = ti.name.substr(strlen("EventType::"));
            if (!ti.category.empty()) name_to_category[shortname] = ti.category;
        }
    }

    // Group ordered entries by category while preserving first-seen category order
    std::vector<std::string> category_order;
    std::unordered_map<std::string, std::vector<EventEntry>> by_cat;
    for (const auto &e : ordered) {
        std::string cat = "Uncategorized";
        auto it = name_to_category.find(e.name);
        if (it != name_to_category.end() && !it->second.empty()) cat = it->second;
        if (by_cat.find(cat) == by_cat.end()) category_order.push_back(cat);
        by_cat[cat].push_back(e);
    }

    // Sort entries within each category by numeric id
    for (auto &kv : by_cat) {
        auto &vec = kv.second;
        std::stable_sort(vec.begin(), vec.end(), [](const EventEntry &a, const EventEntry &b){
            return a.id < b.id;
        });
    }

    // Helper to write a single file path
    auto write_header = [&](const std::filesystem::path &outpath) -> bool {
        std::error_code ec;
        std::filesystem::create_directories(outpath.parent_path(), ec);
        std::ofstream ofs(outpath.string(), std::ios::trunc);
        if (!ofs) return false;

        ofs << "/**\n";
        ofs << " * @file SDOM_CAPI_Events.h\n";
        ofs << " * @brief Stable C API enumeration of SDOM EventType values.\n";
        ofs << " *\n";
        ofs << " * This header is autogenerated by the SDOM CBindingGenerator from the\n";
        ofs << " * project's `DataRegistry` metadata. It provides stable numeric IDs for\n";
        ofs << " * all known `EventType` values and inline documentation for each entry.\n";
        ofs << " *\n";
        ofs << " * @since SDOM 0.5\n";
        ofs << " * @note AUTOGENERATED - DO NOT EDIT. Regenerate with the repository's\n";
        ofs << " *       `dataregistry_generator` when event metadata changes.\n";
        ofs << " */        \n";
        // ofs << "/* Generated SDOM_CAPI_Events.h */\n";
        // ofs << "/* AUTOGENERATED - DO NOT EDIT */\n";
        // ofs << "/* Generated by SDOM CBindingGenerator from SDOM version " << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH << " */\n\n";
        ofs << "#pragma once\n\n";
        // Try to inline the generated objects header (if present in the
        // generator output directory). This lets consumers include a single
        // `SDOM_CAPI_Events.h` that contains both the event IDs and the
        // generated object prototypes without needing the build include
        // path. If the file is not present, fall back to emitting only the
        // event enums.
        // Include the common C API helpers first, then the generated objects
        // header. Emitting the common header ensures generated code uses the
        // centralized error codes and string helpers (`SDOM_StrDup`/`SDOM_FreeString`).
        ofs << "/* Common C API (error codes, free helper) */\n";
        ofs << "#include <SDOM/CAPI/SDOM_CAPI_Common.h>\n\n";
        ofs << "/* Include generated objects header (must be on include path) */\n";
        ofs << "#include \"sdom_capi_objects_generated.h\"\n\n";
        // Emit a small, stable C descriptor-based API for EventTypes and Events.
        // This avoids generating per-property functions and instead provides
        // a few generic handle-based functions that operate on descriptor
        // structs. The struct definitions are paired with their accessor
        // prototypes for ease-of-use and language bindings.
        ofs << "#include <stdint.h>\n";
        ofs << "#include <stddef.h>\n\n";

        ofs << "/* Opaque handle types */\n";
        ofs << "typedef struct SDOM_EventTypeHandle_ *SDOM_EventTypeHandle;\n";
        ofs << "typedef struct SDOM_EventHandle_ *SDOM_EventHandle;\n\n";

        ofs << "/* EventType descriptor: common stable fields plus extensible JSON */\n";
        ofs << "struct SDOM_EventTypeDesc {\n";
        ofs << "    const char *name; /* display / canonical name */\n";
        ofs << "    uint32_t id; /* SDOM_EventTypeId (numeric id) */\n";
        ofs << "    const char *category; /* category/grouping */\n";
        ofs << "    const char *doc; /* short documentation string */\n";
        ofs << "    const char *metadata_json; /* optional JSON for extensible fields (nullable) */\n";
        ofs << "    void *user_data; /* reserved for callers */\n";
        ofs << "};\n\n";

        // Wrap the C API prototypes in extern "C" for C++ consumers
        ofs << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";
        ofs << "/* Paired generic APIs for EventType */\n";
        ofs << "SDOM_EventTypeHandle SDOM_CreateEventType(const struct SDOM_EventTypeDesc *desc);\n";
        ofs << "int SDOM_GetEventTypeDesc(SDOM_EventTypeHandle h, struct SDOM_EventTypeDesc *out);\n";
        ofs << "int SDOM_UpdateEventType(SDOM_EventTypeHandle h, const struct SDOM_EventTypeDesc *desc);\n";
        ofs << "void SDOM_DestroyEventType(SDOM_EventTypeHandle h);\n";
        ofs << "SDOM_EventTypeHandle SDOM_FindEventTypeByName(const char *name);\n";
        ofs << "size_t SDOM_EnumEventTypes(size_t index, SDOM_EventTypeHandle *out); /* iterate by index */\n\n";

        ofs << "/* Event descriptor: payload is represented as JSON for extensibility */\n";
        ofs << "struct SDOM_EventDesc {\n";
        ofs << "    uint32_t type_id; /* EventType numeric id */\n";
        ofs << "    const char *name; /* optional event name */\n";
        ofs << "    const char *payload_json; /* optional JSON payload (nullable) */\n";
        ofs << "    void *user_data; /* reserved for callers */\n";
        ofs << "};\n\n";

        ofs << "/* Paired generic APIs for Events */\n";
        ofs << "SDOM_EventHandle SDOM_CreateEvent(const struct SDOM_EventDesc *desc);\n";
        ofs << "int SDOM_GetEventDesc(SDOM_EventHandle h, struct SDOM_EventDesc *out);\n";
        ofs << "int SDOM_UpdateEvent(SDOM_EventHandle h, const struct SDOM_EventDesc *desc);\n";
        ofs << "void SDOM_DestroyEvent(SDOM_EventHandle h);\n";
        ofs << "int SDOM_SendEvent(SDOM_EventHandle h);\n\n";
        // Expose a small C API helper to query the current event queue size
        // This allows C tests and FFI clients to inspect queue length without
        // depending on C++ internals.
        ofs << "/* Query the current event queue size (number of queued events) */\n";
        ofs << "int SDOM_GetEventQueueSize(void);\n\n";
        ofs << "typedef uint32_t SDOM_EventTypeId;\n\n";
        // Doxygen group for helper macros
        ofs << "/** @defgroup SDOM_EventMacros Event Macros\n";
        ofs << " *  Helpers for extracting category/index from event IDs.\n";
        ofs << " *  @{ */\n";
        ofs << "// Helpers to extract category and index from an event id:\n";
        ofs << "#define SDOM_EVENT_CATEGORY(id) (((uint32_t)(id)) >> 8)\n";
        ofs << "#define SDOM_EVENT_INDEX(id) (((uint32_t)(id)) & 0xFFU)\n\n";
        ofs << "/** @} */\n\n";
        // Doxygen group for the event id enum
        ofs << "/** @defgroup SDOM_EventTypeIDs SDOM EventType IDs\n";
        ofs << " *  @brief Autogenerated ID constants for all SDOM EventTypes.\n";
        ofs << " *  @{ */\n";
        ofs << "/** @ingroup SDOM_EventTypeIDs */\n";
        ofs << "typedef enum SDOM_EventType {\n";
        // Emit a reserved sentinel at 0. Keep 0 unused so real EventType ids
        // start at 1; this avoids confusion with "no event" semantics on
        // consumers that treat 0 as invalid/unused.
        // (Sentinel will be emitted within the Core category block so it appears
        // alongside other core/misc entries. This keeps 0x0000 usable as the
        // first value in that category while remaining a documented sentinel.)
        // helper: convert a PascalCase/CamelCase name into SCREAMING_SNAKE_CASE
        auto to_screaming_snake = [](const std::string &s) -> std::string {
            std::string out;
            out.reserve(s.size()*2);
            for (size_t i = 0; i < s.size(); ++i) {
                char c = s[i];
                if (c == ':' || c == ' ' || c == '-') {
                    if (out.empty() || out.back() == '_') continue;
                    out.push_back('_');
                    continue;
                }
                if (std::isupper(static_cast<unsigned char>(c))) {
                    if (!out.empty() && out.back() != '_') {
                        char prev = s[i>0?i-1:0];
                        bool prev_lower = std::islower(static_cast<unsigned char>(prev));
                        bool prev_upper = std::isupper(static_cast<unsigned char>(prev));
                        bool next_lower = (i+1 < s.size() && std::islower(static_cast<unsigned char>(s[i+1])));
                        if (prev_lower || (prev_upper && next_lower)) out.push_back('_');
                    }
                    out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));
                    continue;
                }
                // lowercase or other chars: convert to upper and append
                out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));
            }
            // collapse repeated underscores
            std::string dst;
            dst.reserve(out.size());
            for (char ch : out) {
                if (ch == '_' && !dst.empty() && dst.back() == '_') continue;
                dst.push_back(ch);
            }
            // trim leading/trailing underscores
            if (!dst.empty() && dst.front() == '_') dst.erase(dst.begin());
            if (!dst.empty() && dst.back() == '_') dst.pop_back();
            return dst;
        };

        // Emit entries grouped by category
        for (const auto &cat : category_order) {
            // Emit a category banner comment
            ofs << "\n    /* " << cat << " -------------------------------------------------------------- */\n";
            // If this is the Core category, emit the reserved sentinel as the
            // first entry (0x0000) so it lives alongside other core events.
            if (cat == "Core") {
                std::ostringstream base;
                base << "    SDOM_EVENT_FIRST = 0x" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << 0 << std::dec << ",";
                std::string baseStr = base.str();
                const size_t target_col = 44;
                size_t baseLen = baseStr.size();
                size_t pad = (baseLen >= target_col) ? 1 : (target_col - baseLen);
                ofs << baseStr << std::string(pad, ' ') << " /**< Reserved (do not use) */\n";
            }
            const auto &vec = by_cat[cat];
            bool firstInCat = true;
            uint32_t last_id = 0;
            for (const auto &kv : vec) {
                // sanitize identifier
                std::string idname = to_screaming_snake(kv.name);

                // No special-case skipping: emit all entries (including "None")
                // so that numeric ids reflect runtime assignment.

                // Build base entry (with trailing comma) and then append comment
                std::ostringstream base;
                std::string baseStr;
                // Decide whether to emit explicit value:
                // - always emit explicit for the first entry in a category
                // - for subsequent entries omit the value if id == last_id + 1
                // - otherwise emit explicit value
                if (firstInCat) {
                    uint32_t id32 = kv.id;
                    base << "    SDOM_EVENT_" << idname << " = 0x" << std::hex << std::uppercase << std::setfill('0') << std::setw(8) << id32 << std::dec << ",";
                } else {
                    if (kv.id == last_id + 1) {
                        base << "    SDOM_EVENT_" << idname << ",";
                    } else {
                        uint32_t id32 = kv.id;
                        base << "    SDOM_EVENT_" << idname << " = 0x" << std::hex << std::uppercase << std::setfill('0') << std::setw(8) << id32 << std::dec << ",";
                    }
                }
                baseStr = base.str();

                if (!kv.doc.empty()) {
                    std::string doc = kv.doc;
                    for (char &c : doc) if (c == '\n' || c == '\r') c = ' ';

                    const size_t target_col = 44;
                    size_t baseLen = baseStr.size();
                    size_t pad = (baseLen >= target_col) ? 1 : (target_col - baseLen);
                    ofs << baseStr << std::string(pad, ' ') << " /**< " << doc << " */\n";
                } else {
                    ofs << baseStr << "\n";
                }

                last_id = kv.id;
                firstInCat = false;
            }
        }

        ofs << "    /**\n";
        ofs << "     *  This last event is only for bounding internal arrays\n";
        ofs << "     */\n";
        ofs << "    SDOM_EVENT_LAST    = 0xFFFF,\n\n";
        ofs << "    /* This just makes sure the enum is the size of Uint32 */\n";
        ofs << "    SDOM_EVENT_ENUM_PADDING = 0x7FFFFFFF\n";
        ofs << "} SDOM_EventType;\n\n";

        // Close the Doxygen group for SDOM_EventTypeIDs
        ofs << "/** @} */\n\n";

        ofs << "#ifdef __cplusplus\n}\n#endif\n";
        ofs.close();
        std::cout << "[CBindingGenerator] wrote " << outpath.string() << std::endl;
        return true;
    };

    // Primary output (generator-specified directory)
    std::filesystem::path primary = join_path(outputDir, "SDOM_CAPI_Events.h");
    bool ok = write_header(primary);

    // Also write into the repository include path: search upward for a
    // directory containing a top-level CMakeLists.txt and write to
    // REPO_ROOT/include/SDOM/CAPI/SDOM_CAPI_Events.h if found.
    std::filesystem::path cwd = std::filesystem::current_path();
    std::filesystem::path repo_root;
    for (auto p = cwd; ; p = p.parent_path()) {
        if (p == p.parent_path()) break; // reached filesystem root
        if (std::filesystem::exists(p / "CMakeLists.txt")) { repo_root = p; break; }
    }
    if (!repo_root.empty()) {
        std::filesystem::path repo_out = repo_root / "include" / "SDOM" / "CAPI" / "SDOM_CAPI_Events.h";
        // best-effort write; ignore failures
        try { write_header(repo_out); } catch(...) {}
    }

    // Also emit a thin generated implementation into the repository so that
    // the repo-level copy of the C API is self-contained and compiled into
    // the SDOM library. This mirrors the hand-edited implementation that
    // provides handle-owned stable C strings and descriptor-based wrappers.
    if (!repo_root.empty()) {
        try {
            std::filesystem::path impl_dir = repo_root / "src" / "CAPI";
            std::error_code ec;
            std::filesystem::create_directories(impl_dir, ec);
            if (!ec) {
                std::filesystem::path impl_out = impl_dir / "SDOM_CAPI_Events_gen.cpp";
                std::ofstream ifs(impl_out.string(), std::ios::trunc);
                if (ifs) {
                    ifs << "// Autogenerated implementation: do not edit\n";
                    ifs << "#include <SDOM/CAPI/SDOM_CAPI_Events.h>\n";
                    ifs << "#include <string>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cstdlib>\n";
                    ifs << "#include <SDOM/SDOM_EventType.hpp>\n#include <SDOM/SDOM_Event.hpp>\n#include <SDOM/SDOM_EventManager.hpp>\n#include <SDOM/SDOM_Core.hpp>\n\n";
                    ifs << "// Use SDOM_StrDup()/SDOM_FreeString() declared in SDOM_CAPI_Common.h for string lifetime management.\n\n";
                    ifs << "struct SDOM_EventTypeHandle_ { SDOM::EventType* ptr = nullptr; char* name = nullptr; char* category = nullptr; char* doc = nullptr; bool owns = false; SDOM_EventTypeHandle_() = default; ~SDOM_EventTypeHandle_(){ if (name) SDOM_FreeString(name); if (category) SDOM_FreeString(category); if (doc) SDOM_FreeString(doc); } };\n\n";
                    ifs << "struct SDOM_EventHandle_ { SDOM::Event* ptr = nullptr; char* name = nullptr; char* payload_json = nullptr; SDOM_EventHandle_() = default; ~SDOM_EventHandle_(){ if (name) SDOM_FreeString(name); if (payload_json) SDOM_FreeString(payload_json); } };\n\n";
                    ifs << "// Use centralized error macros from SDOM_CAPI_Common.h\n\n";
                    ifs << "SDOM_EventTypeHandle SDOM_CreateEventType(const struct SDOM_EventTypeDesc *desc) { if (!desc || !desc->name) return nullptr; try { SDOM::EventType* et = nullptr; const std::string name = desc->name ? std::string(desc->name) : std::string(); const char* cat = desc->category; const char* doc = desc->doc; if (cat) { const std::string category = std::string(cat); const std::string docstr = doc ? std::string(doc) : std::string(); et = new SDOM::EventType(name, category, docstr); } else if (doc) { et = new SDOM::EventType(name); et->setDoc(std::string(doc)); } else { et = new SDOM::EventType(name); } auto h = new SDOM_EventTypeHandle_(); h->ptr = et; h->owns = true; h->name = SDOM_StrDup(et->getName().c_str()); h->category = SDOM_StrDup(et->getCategory().c_str()); h->doc = SDOM_StrDup(et->getDoc().c_str()); return reinterpret_cast<SDOM_EventTypeHandle>(h); } catch(...) { return nullptr; } }\n\n";
                    ifs << "int SDOM_GetEventTypeDesc(SDOM_EventTypeHandle h, struct SDOM_EventTypeDesc *out) { if (!h || !out) return SDOM_CAPI_ERR_INVALID_ARG; SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG; SDOM::EventType* et = hh->ptr; out->name = hh->name ? hh->name : et->getName().c_str(); out->id = static_cast<uint32_t>(et->getOrAssignId()); out->category = hh->category ? hh->category : et->getCategory().c_str(); out->doc = hh->doc ? hh->doc : et->getDoc().c_str(); out->metadata_json = nullptr; out->user_data = nullptr; return SDOM_CAPI_OK; }\n\n";
                    ifs << "int SDOM_UpdateEventType(SDOM_EventTypeHandle h, const struct SDOM_EventTypeDesc *desc) { if (!h || !desc) return SDOM_CAPI_ERR_INVALID_ARG; SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG; SDOM::EventType* et = hh->ptr; if (desc->doc) et->setDoc(std::string(desc->doc)); if (desc->category) et->setCategory(std::string(desc->category)); if (desc->id != 0) et->setId(static_cast<SDOM::EventType::IdType>(desc->id)); if (desc->doc) { if (hh->doc) SDOM_FreeString(hh->doc); hh->doc = SDOM_StrDup(desc->doc); } if (desc->category) { if (hh->category) SDOM_FreeString(hh->category); hh->category = SDOM_StrDup(desc->category); } return SDOM_CAPI_OK; }\n\n";
                    ifs << "void SDOM_DestroyEventType(SDOM_EventTypeHandle h) { if (!h) return; SDOM_EventTypeHandle_* hh = reinterpret_cast<SDOM_EventTypeHandle_*>(h); delete hh; }\n\n";
                    ifs << "SDOM_EventTypeHandle SDOM_FindEventTypeByName(const char *name) { if (!name) return nullptr; SDOM::EventType* et = SDOM::EventType::fromName(std::string(name)); if (!et) return nullptr; auto h = new SDOM_EventTypeHandle_(); h->ptr = et; h->name = SDOM_StrDup(et->getName().c_str()); h->category = SDOM_StrDup(et->getCategory().c_str()); h->doc = SDOM_StrDup(et->getDoc().c_str()); return reinterpret_cast<SDOM_EventTypeHandle>(h); }\n\n";
                    ifs << "size_t SDOM_EnumEventTypes(size_t index, SDOM_EventTypeHandle *out) { auto all = SDOM::EventType::getAll(); if (index >= all.size()) return 0; if (out) { SDOM::EventType* et = all[index]; auto h = new SDOM_EventTypeHandle_(); h->ptr = et; h->name = SDOM_StrDup(et->getName().c_str()); h->category = SDOM_StrDup(et->getCategory().c_str()); h->doc = SDOM_StrDup(et->getDoc().c_str()); *out = reinterpret_cast<SDOM_EventTypeHandle>(h); } return index + 1; }\n\n";
                    ifs << "SDOM_EventHandle SDOM_CreateEvent(const struct SDOM_EventDesc *desc) { if (!desc) return nullptr; SDOM::EventType* et = nullptr; if (desc->type_id != 0) { et = SDOM::EventType::fromId(static_cast<SDOM::EventType::IdType>(desc->type_id)); } if (!et) { if (desc->name) et = SDOM::EventType::fromName(std::string(desc->name)); } SDOM::Event* ev = nullptr; if (et) { ev = new SDOM::Event(*et); } else { ev = new SDOM::Event(SDOM::EventType(\"None\")); } auto h = new SDOM_EventHandle_(); h->ptr = ev; try { h->name = SDOM_StrDup(ev->getType().getName().c_str()); } catch(...) { h->name = nullptr; } return reinterpret_cast<SDOM_EventHandle>(h); }\n\n";
                    ifs << "int SDOM_GetEventDesc(SDOM_EventHandle h, struct SDOM_EventDesc *out) { if (!h || !out) return SDOM_CAPI_ERR_INVALID_ARG; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG; SDOM::Event* ev = hh->ptr; out->type_id = static_cast<uint32_t>(ev->getType().getOrAssignId()); out->name = hh->name ? hh->name : ev->getTypeName().c_str(); out->payload_json = nullptr; out->user_data = nullptr; return SDOM_CAPI_OK; }\n\n";
                    ifs << "int SDOM_UpdateEvent(SDOM_EventHandle h, const SDOM_EventDesc *desc) { if (!h || !desc) return SDOM_CAPI_ERR_INVALID_ARG; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG; (void)hh; (void)desc; return SDOM_CAPI_OK; }\n\n";
                    ifs << "void SDOM_DestroyEvent(SDOM_EventHandle h) { if (!h) return; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (hh->ptr) delete hh->ptr; delete hh; }\n\n";
                    ifs << "int SDOM_SendEvent(SDOM_EventHandle h) { if (!h) return SDOM_CAPI_ERR_INVALID_ARG; SDOM_EventHandle_* hh = reinterpret_cast<SDOM_EventHandle_*>(h); if (!hh->ptr) return SDOM_CAPI_ERR_INVALID_ARG; try { auto evCopy = std::make_unique<SDOM::Event>(*hh->ptr); SDOM::Core::getInstance().getEventManager().addEvent(std::move(evCopy)); return SDOM_CAPI_OK; } catch(...) { return SDOM_CAPI_ERR_INTERNAL; } }\n";
                    // Implementation: query event queue size via Core singleton
                    ifs << "int SDOM_GetEventQueueSize(void) { try { return SDOM::Core::getInstance().getEventManager().getEventQueueSize(); } catch(...) { return -1; } }\n";
                    ifs.close();
                    std::cout << "[CBindingGenerator] wrote " << impl_out.string() << std::endl;
                }
            }
        } catch(...) {}
    }

    return ok;
}
