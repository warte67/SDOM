#include <SDOM/SDOM_CBindingGenerator.hpp>
#include <SDOM/SDOM_DataRegistry.hpp>
#include <filesystem>
#include <fstream>
#include <iomanip>

#include <SDOM/SDOM_Version.hpp>
#include <SDOM/SDOM_EventType.hpp>
#include <unordered_map>

// Local generator-only event id registry to avoid linking the full runtime
[[maybe_unused]] static std::unordered_map<std::string, uint32_t> s_local_event_id_map;
[[maybe_unused]] static uint32_t s_local_next_event_id = 1;

using namespace SDOM;
namespace fs = std::filesystem;

static std::string join_path(const std::string &a, const std::string &b) {
    fs::path p(a);
    p /= b;
    return p.string();
}

bool CBindingGenerator::generate(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Create output dir if missing
    std::error_code ec;
    fs::create_directories(outputDir, ec);
    if (ec) return false;

    const std::string filename = join_path(outputDir, "sdom_capi_objects_generated.h");
    std::ofstream ofs(filename, std::ios::trunc);
    if (!ofs) return false;

    // Emit version macros so consumers can quickly check the C API version
    ofs << "/* Generated by SDOM CBindingGenerator */\n";
    ofs << "#ifndef SDOM_CAPI_OBJECTS_GENERATED_H\n";
    ofs << "#define SDOM_CAPI_OBJECTS_GENERATED_H\n\n";

    // Version macros taken from SDOM build
    ofs << "#define SDOM_CAPI_GENERATED_MAJOR " << SDOM_VERSION_MAJOR << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_MINOR " << SDOM_VERSION_MINOR << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_PATCH " << SDOM_VERSION_PATCH << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_VERSION_STRING \"" << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH << "\"\n\n";

    ofs << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";

    // Emit a typedef for a handle type and forward declarations for each type
    ofs << "typedef void* sdom_handle_t;\n\n";

    for (const auto &ti : snapshot.types) {
        const std::string &tname = ti.name;
        // sanitize name for C identifier: replace ':' and ' ' with '_'
        std::string id = tname;
        for (char &c : id) if (c == ':' || c == ' ') c = '_';

        ofs << "/* Type: " << tname << " */\n";
        ofs << "typedef struct " << id << "_t* " << id << "_handle;\n";
        ofs << "sdom_handle_t sdom_create_" << id << "(void);\n";
        ofs << "void sdom_destroy_" << id << "(sdom_handle_t);\n\n";
    }

    // Emit any explicit C function prototypes registered in the DataRegistry
    // If a FunctionInfo includes a `c_signature`, prefer that. Otherwise
    // emit a simple fallback prototype using the function name.
    ofs << "/* Exported C API function prototypes (generated) */\n";
    for (const auto &ti : snapshot.types) {
        for (const auto &fi : ti.functions) {
            if (!fi.exported) continue;
            if (!fi.c_signature.empty()) {
                ofs << fi.c_signature << "\n";
            } else if (!fi.c_name.empty()) {
                ofs << "/* fallback */ extern \"C\" void " << fi.c_name << "(void);\n";
            } else {
                ofs << "/* fallback */ extern \"C\" void " << fi.name << "(void);\n";
            }
        }
    }

    ofs << "#ifdef __cplusplus\n}\n#endif\n\n";
    ofs << "#endif // SDOM_CAPI_OBJECTS_GENERATED_H\n";

    ofs.close();

    // Also write a marker file and a simple .version file for quick parsing
    std::ofstream marker(join_path(outputDir, ".c_binding_generator_marker"));
    if (marker) marker << "generated" << std::endl;

    // version file
    std::ostringstream ver;
    ver << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH;
    std::ofstream vfh(join_path(outputDir, "sdom_capi_objects_generated.version"));
    if (vfh) vfh << ver.str() << std::endl;

    // Emit event-specific bindings/header
    try {
        generateEventBindings(snapshot, outputDir);
    } catch(...) {}
    try {
        emitCAPIEventsHeader(snapshot, outputDir);
    } catch(...) {}

    return true;
}

bool CBindingGenerator::generateEventBindings(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Emit a small file that lists types that look like Event or EventType
    const std::string filename = join_path(outputDir, "sdom_event_bindings_generated.h");
    std::ofstream ofs(filename, std::ios::trunc);
    if (!ofs) return false;

    ofs << "/* Generated Event bindings (stub) */\n";
    ofs << "#pragma once\n\n";
    ofs << "// Types discovered in registry snapshot:\n";
    for (const auto &ti : snapshot.types) {
        if (ti.name.find("Event") != std::string::npos) {
            ofs << "// " << ti.name << "\n";
        }
    }
    ofs.close();
    std::cout << "[CBindingGenerator] wrote " << filename << std::endl;
    return true;
}

bool CBindingGenerator::emitCAPIEventsHeader(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Build a deterministic list of EventType entries from the registry
    // Map event short-name -> docstring (if present)
    std::unordered_map<std::string, std::string> event_docs;
    std::vector<std::string> events;
    for (const auto &ti : snapshot.types) {
        // We registered per-instance EventType entries as "EventType::<name>"
        if (ti.name.rfind("EventType::", 0) == 0) {
            std::string shortname = ti.name.substr(strlen("EventType::"));
            events.push_back(shortname);
            if (!ti.doc.empty()) event_docs[shortname] = ti.doc;
        }
    }

    (void)event_docs; // silence unused when debug removed

    // Build ordered list of events, preferring runtime-assigned EventType ids.
    // To avoid fallback ids colliding or interleaving with runtime ids we
    // first collect any runtime ids, pick a fallback start value after the
    // maximum runtime id, then assign fallback ids sequentially.
    struct EventEntry { std::string name; uint32_t id; std::string doc; };
    std::vector<EventEntry> ordered;

    // First pass: collect runtime ids where available and remember which
    // names need fallback ids.
    std::vector<std::string> need_fallback;
    uint32_t max_runtime_id = 0;
    for (const auto &n : events) {
        try {
            SDOM::EventType* et = SDOM::EventType::fromName(n);
            if (et) {
                uint32_t rid = static_cast<uint32_t>(et->getOrAssignId());
                EventEntry e{n, rid, ""};
                // Prefer runtime-provided docstring when available; fall back
                // to snapshot-provided docs if runtime doc is empty.
                try {
                    std::string rd = et->getDoc();
                    if (!rd.empty()) e.doc = rd;
                } catch(...) {}
                if (e.doc.empty()) {
                    auto it = event_docs.find(n);
                    if (it != event_docs.end()) e.doc = it->second;
                }
                ordered.push_back(std::move(e));
                if (rid > max_runtime_id) max_runtime_id = rid;
                continue;
            }
        } catch(...) {
            // ignore and mark for fallback
        }
        need_fallback.push_back(n);
    }

    // Start fallback ids after the max runtime id to keep runtime-assigned
    // ids ordered before any generated fallbacks.
    uint32_t fallback_next_id = (max_runtime_id >= 1) ? (max_runtime_id + 1) : 1u;
    for (const auto &n : need_fallback) {
        EventEntry e{n, fallback_next_id++, ""};
        auto it = event_docs.find(n);
        if (it != event_docs.end()) e.doc = it->second;
        ordered.push_back(std::move(e));
    }

    // Sort by numeric id (stable to preserve the earlier order for ties).
    std::stable_sort(ordered.begin(), ordered.end(), [](const EventEntry &a, const EventEntry &b){
        return a.id < b.id;
    });

    // Helper to write a single file path
    auto write_header = [&](const std::filesystem::path &outpath) -> bool {
        std::error_code ec;
        std::filesystem::create_directories(outpath.parent_path(), ec);
        std::ofstream ofs(outpath.string(), std::ios::trunc);
        if (!ofs) return false;
        ofs << "/* Generated SDOM_CAPI_Events.h */\n";
        ofs << "/* AUTOGENERATED - DO NOT EDIT */\n";
        ofs << "/* Generated by SDOM CBindingGenerator from SDOM version " << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH << " */\n\n";
        ofs << "#pragma once\n\n";
        ofs << "#include <stdint.h>\n\n";
        ofs << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";
        ofs << "typedef uint32_t SDOM_EventTypeId;\n\n";
        ofs << "typedef enum SDOM_EventType {\n";
        // Emit NONE with optional inline doc comment. Prefer runtime EventType
        // doc when available, falling back to the snapshot-provided doc.
        ofs << "    SDOM_EVENT_NONE = 0";
        std::string none_doc;
        try {
            SDOM::EventType* et = SDOM::EventType::fromName("None");
            if (et) none_doc = et->getDoc();
        } catch(...) { none_doc.clear(); }
        if (none_doc.empty()) {
            auto _none_it = event_docs.find("None");
            if (_none_it != event_docs.end()) none_doc = _none_it->second;
        }
        if (!none_doc.empty()) {
            for (char &c : none_doc) if (c == '\n' || c == '\r') c = ' ';
            ofs << ", /* " << none_doc << " */\n";
        } else {
            ofs << ",\n";
        }
        // helper: convert a PascalCase/CamelCase name into SCREAMING_SNAKE_CASE
        auto to_screaming_snake = [](const std::string &s) -> std::string {
            std::string out;
            out.reserve(s.size()*2);
            for (size_t i = 0; i < s.size(); ++i) {
                char c = s[i];
                if (c == ':' || c == ' ' || c == '-') {
                    if (out.empty() || out.back() == '_') continue;
                    out.push_back('_');
                    continue;
                }
                if (std::isupper(static_cast<unsigned char>(c))) {
                    if (!out.empty() && out.back() != '_') {
                        char prev = s[i>0?i-1:0];
                        bool prev_lower = std::islower(static_cast<unsigned char>(prev));
                        bool prev_upper = std::isupper(static_cast<unsigned char>(prev));
                        bool next_lower = (i+1 < s.size() && std::islower(static_cast<unsigned char>(s[i+1])));
                        if (prev_lower || (prev_upper && next_lower)) out.push_back('_');
                    }
                    out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));
                    continue;
                }
                // lowercase or other chars: convert to upper and append
                out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));
            }
            // collapse repeated underscores
            std::string dst;
            dst.reserve(out.size());
            for (char ch : out) {
                if (ch == '_' && !dst.empty() && dst.back() == '_') continue;
                dst.push_back(ch);
            }
            // trim leading/trailing underscores
            if (!dst.empty() && dst.front() == '_') dst.erase(dst.begin());
            if (!dst.empty() && dst.back() == '_') dst.pop_back();
            return dst;
        };

        for (const auto &kv : ordered) {
            // sanitize identifier
            std::string idname = to_screaming_snake(kv.name);

            // Skip duplicate NONE entry: we emit SDOM_EVENT_NONE = 0 above.
            if (idname == "NONE") continue;

            // Emit the enum entry with optional inline doc comment
            ofs << "    SDOM_EVENT_" << idname << " = " << kv.id;
            if (!kv.doc.empty()) {
                std::string doc = kv.doc;
                for (char &c : doc) if (c == '\n' || c == '\r') c = ' ';
                ofs << ", /* " << doc << " */\n";
            } else {
                ofs << ",\n";
            }
        }

        ofs << "    /**\n";
        ofs << "     *  This last event is only for bounding internal arrays\n";
        ofs << "     */\n";
        ofs << "    SDOM_EVENT_LAST    = 0xFFFF,\n\n";
        ofs << "    /* This just makes sure the enum is the size of Uint32 */\n";
        ofs << "    SDOM_EVENT_ENUM_PADDING = 0x7FFFFFFF\n";
        ofs << "} SDOM_EventType;\n\n";

        ofs << "#ifdef __cplusplus\n}\n#endif\n";
        ofs.close();
        std::cout << "[CBindingGenerator] wrote " << outpath.string() << std::endl;
        return true;
    };

    // Primary output (generator-specified directory)
    std::filesystem::path primary = join_path(outputDir, "SDOM_CAPI_Events.h");
    bool ok = write_header(primary);

    // Also write into the repository include path: search upward for a
    // directory containing a top-level CMakeLists.txt and write to
    // REPO_ROOT/include/SDOM/CAPI/SDOM_CAPI_Events.h if found.
    std::filesystem::path cwd = std::filesystem::current_path();
    std::filesystem::path repo_root;
    for (auto p = cwd; ; p = p.parent_path()) {
        if (p == p.parent_path()) break; // reached filesystem root
        if (std::filesystem::exists(p / "CMakeLists.txt")) { repo_root = p; break; }
    }
    if (!repo_root.empty()) {
        std::filesystem::path repo_out = repo_root / "include" / "SDOM" / "CAPI" / "SDOM_CAPI_Events.h";
        // best-effort write; ignore failures
        try { write_header(repo_out); } catch(...) {}
    }

    return ok;
}
