#include <SDOM/SDOM_CBindingGenerator.hpp>
#include <SDOM/SDOM_DataRegistry.hpp>
#include <filesystem>
#include <fstream>
#include <iomanip>

#include <SDOM/SDOM_Version.hpp>
#include <SDOM/SDOM_EventType.hpp>
#include <unordered_map>

// Local generator-only event id registry to avoid linking the full runtime
[[maybe_unused]] static std::unordered_map<std::string, uint32_t> s_local_event_id_map;
[[maybe_unused]] static uint32_t s_local_next_event_id = 1;

using namespace SDOM;
namespace fs = std::filesystem;

static std::string join_path(const std::string &a, const std::string &b) {
    fs::path p(a);
    p /= b;
    return p.string();
}

bool CBindingGenerator::generate(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Create output dir if missing
    std::error_code ec;
    fs::create_directories(outputDir, ec);
    if (ec) return false;

    const std::string filename = join_path(outputDir, "sdom_capi_objects_generated.h");
    std::ofstream ofs(filename, std::ios::trunc);
    if (!ofs) return false;

    // Emit version macros so consumers can quickly check the C API version
    ofs << "/* Generated by SDOM CBindingGenerator */\n";
    ofs << "#ifndef SDOM_CAPI_OBJECTS_GENERATED_H\n";
    ofs << "#define SDOM_CAPI_OBJECTS_GENERATED_H\n\n";

    // Version macros taken from SDOM build
    ofs << "#define SDOM_CAPI_GENERATED_MAJOR " << SDOM_VERSION_MAJOR << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_MINOR " << SDOM_VERSION_MINOR << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_PATCH " << SDOM_VERSION_PATCH << "\n";
    ofs << "#define SDOM_CAPI_GENERATED_VERSION_STRING \"" << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH << "\"\n\n";

    ofs << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";

    // Emit a typedef for a handle type and forward declarations for each type
    ofs << "typedef void* sdom_handle_t;\n\n";

    for (const auto &ti : snapshot.types) {
        const std::string &tname = ti.name;
        // sanitize name for C identifier: replace ':' and ' ' with '_'
        std::string id = tname;
        for (char &c : id) if (c == ':' || c == ' ') c = '_';

        ofs << "/* Type: " << tname << " */\n";
        ofs << "typedef struct " << id << "_t* " << id << "_handle;\n";
        ofs << "sdom_handle_t sdom_create_" << id << "(void);\n";
        ofs << "void sdom_destroy_" << id << "(sdom_handle_t);\n\n";
    }

    // Emit any explicit C function prototypes registered in the DataRegistry
    // If a FunctionInfo includes a `c_signature`, prefer that. Otherwise
    // emit a simple fallback prototype using the function name.
    ofs << "/* Exported C API function prototypes (generated) */\n";
    for (const auto &ti : snapshot.types) {
        for (const auto &fi : ti.functions) {
            if (!fi.exported) continue;
            if (!fi.c_signature.empty()) {
                ofs << fi.c_signature << "\n";
            } else if (!fi.c_name.empty()) {
                ofs << "/* fallback */ extern \"C\" void " << fi.c_name << "(void);\n";
            } else {
                ofs << "/* fallback */ extern \"C\" void " << fi.name << "(void);\n";
            }
        }
    }

    ofs << "#ifdef __cplusplus\n}\n#endif\n\n";
    ofs << "#endif // SDOM_CAPI_OBJECTS_GENERATED_H\n";

    ofs.close();

    // Also write a marker file and a simple .version file for quick parsing
    std::ofstream marker(join_path(outputDir, ".c_binding_generator_marker"));
    if (marker) marker << "generated" << std::endl;

    // version file
    std::ostringstream ver;
    ver << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH;
    std::ofstream vfh(join_path(outputDir, "sdom_capi_objects_generated.version"));
    if (vfh) vfh << ver.str() << std::endl;

    // Emit event-specific bindings/header
    try {
        generateEventBindings(snapshot, outputDir);
    } catch(...) {}
    try {
        emitCAPIEventsHeader(snapshot, outputDir);
    } catch(...) {}

    return true;
}

bool CBindingGenerator::generateEventBindings(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Emit a small file that lists types that look like Event or EventType
    const std::string filename = join_path(outputDir, "sdom_event_bindings_generated.h");
    std::ofstream ofs(filename, std::ios::trunc);
    if (!ofs) return false;

    ofs << "/* Generated Event bindings (stub) */\n";
    ofs << "#pragma once\n\n";
    ofs << "// Types discovered in registry snapshot:\n";
    for (const auto &ti : snapshot.types) {
        if (ti.name.find("Event") != std::string::npos) {
            ofs << "// " << ti.name << "\n";
        }
    }
    ofs.close();
    std::cout << "[CBindingGenerator] wrote " << filename << std::endl;
    return true;
}

bool CBindingGenerator::emitCAPIEventsHeader(const DataRegistrySnapshot& snapshot, const std::string& outputDir) {
    // Build a deterministic list of EventType entries from the registry
    // Map event short-name -> docstring (if present)
    std::unordered_map<std::string, std::string> event_docs;
    std::vector<std::string> events;
    for (const auto &ti : snapshot.types) {
        // We registered per-instance EventType entries as "EventType::<name>"
        if (ti.name.rfind("EventType::", 0) == 0) {
            std::string shortname = ti.name.substr(strlen("EventType::"));
            events.push_back(shortname);
            if (!ti.doc.empty()) event_docs[shortname] = ti.doc;
        }
    }

    (void)event_docs; // silence unused when debug removed

    // Build ordered list of events, preferring runtime-assigned EventType ids.
    // To avoid fallback ids colliding or interleaving with runtime ids we
    // first collect any runtime ids, pick a fallback start value after the
    // maximum runtime id, then assign fallback ids sequentially.
    struct EventEntry { std::string name; uint32_t id; std::string doc; };
    std::vector<EventEntry> ordered;

    // First pass: collect runtime ids where available and remember which
    // names need fallback ids.
    std::vector<std::string> need_fallback;
    uint32_t max_runtime_id = 0;
    for (const auto &n : events) {
        try {
            SDOM::EventType* et = SDOM::EventType::fromName(n);
            if (et) {
                uint32_t rid = static_cast<uint32_t>(et->getOrAssignId());
                EventEntry e{n, rid, ""};
                // Prefer runtime-provided docstring when available; fall back
                // to snapshot-provided docs if runtime doc is empty.
                try {
                    std::string rd = et->getDoc();
                    if (!rd.empty()) e.doc = rd;
                } catch(...) {}
                if (e.doc.empty()) {
                    auto it = event_docs.find(n);
                    if (it != event_docs.end()) e.doc = it->second;
                }
                ordered.push_back(std::move(e));
                if (rid > max_runtime_id) max_runtime_id = rid;
                continue;
            }
        } catch(...) {
            // ignore and mark for fallback
        }
        need_fallback.push_back(n);
    }

    // Start fallback ids after the max runtime id to keep runtime-assigned
    // ids ordered before any generated fallbacks.
    uint32_t fallback_next_id = (max_runtime_id >= 1) ? (max_runtime_id + 1) : 1u;
    for (const auto &n : need_fallback) {
        EventEntry e{n, fallback_next_id++, ""};
        auto it = event_docs.find(n);
        if (it != event_docs.end()) e.doc = it->second;
        ordered.push_back(std::move(e));
    }

    // Sort by numeric id (stable to preserve the earlier order for ties).
    std::stable_sort(ordered.begin(), ordered.end(), [](const EventEntry &a, const EventEntry &b){
        return a.id < b.id;
    });

    // Build name -> category map from the snapshot (fallback to "Uncategorized")
    std::unordered_map<std::string, std::string> name_to_category;
    for (const auto &ti : snapshot.types) {
        if (ti.name.rfind("EventType::", 0) == 0) {
            std::string shortname = ti.name.substr(strlen("EventType::"));
            if (!ti.category.empty()) name_to_category[shortname] = ti.category;
        }
    }

    // Group ordered entries by category while preserving first-seen category order
    std::vector<std::string> category_order;
    std::unordered_map<std::string, std::vector<EventEntry>> by_cat;
    for (const auto &e : ordered) {
        std::string cat = "Uncategorized";
        auto it = name_to_category.find(e.name);
        if (it != name_to_category.end() && !it->second.empty()) cat = it->second;
        if (by_cat.find(cat) == by_cat.end()) category_order.push_back(cat);
        by_cat[cat].push_back(e);
    }

    // Sort entries within each category by numeric id
    for (auto &kv : by_cat) {
        auto &vec = kv.second;
        std::stable_sort(vec.begin(), vec.end(), [](const EventEntry &a, const EventEntry &b){
            return a.id < b.id;
        });
    }

    // Helper to write a single file path
    auto write_header = [&](const std::filesystem::path &outpath) -> bool {
        std::error_code ec;
        std::filesystem::create_directories(outpath.parent_path(), ec);
        std::ofstream ofs(outpath.string(), std::ios::trunc);
        if (!ofs) return false;

        ofs << "/**\n";
        ofs << " * @file SDOM_CAPI_Events.h\n";
        ofs << " * @brief Stable C API enumeration of SDOM EventType values.\n";
        ofs << " *\n";
        ofs << " * This header is autogenerated by the SDOM CBindingGenerator from the\n";
        ofs << " * project's `DataRegistry` metadata. It provides stable numeric IDs for\n";
        ofs << " * all known `EventType` values and inline documentation for each entry.\n";
        ofs << " *\n";
        ofs << " * @since SDOM 0.5\n";
        ofs << " * @note AUTOGENERATED - DO NOT EDIT. Regenerate with the repository's\n";
        ofs << " *       `dataregistry_generator` when event metadata changes.\n";
        ofs << " */        \n";
        // ofs << "/* Generated SDOM_CAPI_Events.h */\n";
        // ofs << "/* AUTOGENERATED - DO NOT EDIT */\n";
        // ofs << "/* Generated by SDOM CBindingGenerator from SDOM version " << SDOM_VERSION_MAJOR << "." << SDOM_VERSION_MINOR << "." << SDOM_VERSION_PATCH << " */\n\n";
        ofs << "#pragma once\n\n";
        ofs << "#include <stdint.h>\n\n";
        ofs << "#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";
        ofs << "typedef uint32_t SDOM_EventTypeId;\n\n";
        ofs << "// Helpers to extract category and index from an event id:\n";
        ofs << "#define SDOM_EVENT_CATEGORY(id) (((uint32_t)(id)) >> 8)\n";
        ofs << "#define SDOM_EVENT_INDEX(id) (((uint32_t)(id)) & 0xFFU)\n\n";
        ofs << "typedef enum SDOM_EventType {\n";
        // Emit a reserved sentinel at 0. Keep 0 unused so real EventType ids
        // start at 1; this avoids confusion with "no event" semantics on
        // consumers that treat 0 as invalid/unused.
        // (Sentinel will be emitted within the Core category block so it appears
        // alongside other core/misc entries. This keeps 0x0000 usable as the
        // first value in that category while remaining a documented sentinel.)
        // helper: convert a PascalCase/CamelCase name into SCREAMING_SNAKE_CASE
        auto to_screaming_snake = [](const std::string &s) -> std::string {
            std::string out;
            out.reserve(s.size()*2);
            for (size_t i = 0; i < s.size(); ++i) {
                char c = s[i];
                if (c == ':' || c == ' ' || c == '-') {
                    if (out.empty() || out.back() == '_') continue;
                    out.push_back('_');
                    continue;
                }
                if (std::isupper(static_cast<unsigned char>(c))) {
                    if (!out.empty() && out.back() != '_') {
                        char prev = s[i>0?i-1:0];
                        bool prev_lower = std::islower(static_cast<unsigned char>(prev));
                        bool prev_upper = std::isupper(static_cast<unsigned char>(prev));
                        bool next_lower = (i+1 < s.size() && std::islower(static_cast<unsigned char>(s[i+1])));
                        if (prev_lower || (prev_upper && next_lower)) out.push_back('_');
                    }
                    out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));
                    continue;
                }
                // lowercase or other chars: convert to upper and append
                out.push_back(static_cast<char>(std::toupper(static_cast<unsigned char>(c))));
            }
            // collapse repeated underscores
            std::string dst;
            dst.reserve(out.size());
            for (char ch : out) {
                if (ch == '_' && !dst.empty() && dst.back() == '_') continue;
                dst.push_back(ch);
            }
            // trim leading/trailing underscores
            if (!dst.empty() && dst.front() == '_') dst.erase(dst.begin());
            if (!dst.empty() && dst.back() == '_') dst.pop_back();
            return dst;
        };

        // Emit entries grouped by category
        for (const auto &cat : category_order) {
            // Emit a category banner comment
            ofs << "\n    /* " << cat << " -------------------------------------------------------------- */\n";
            // If this is the Core category, emit the reserved sentinel as the
            // first entry (0x0000) so it lives alongside other core events.
            if (cat == "Core") {
                std::ostringstream base;
                base << "    SDOM_EVENT_FIRST = 0x" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << 0 << std::dec << ",";
                std::string baseStr = base.str();
                const size_t target_col = 44;
                size_t baseLen = baseStr.size();
                size_t pad = (baseLen >= target_col) ? 1 : (target_col - baseLen);
                ofs << baseStr << std::string(pad, ' ') << " /**< Reserved (do not use) */\n";
            }
            const auto &vec = by_cat[cat];
            bool firstInCat = true;
            uint32_t last_id = 0;
            for (const auto &kv : vec) {
                // sanitize identifier
                std::string idname = to_screaming_snake(kv.name);

                // No special-case skipping: emit all entries (including "None")
                // so that numeric ids reflect runtime assignment.

                // Build base entry (with trailing comma) and then append comment
                std::ostringstream base;
                std::string baseStr;
                // Decide whether to emit explicit value:
                // - always emit explicit for the first entry in a category
                // - for subsequent entries omit the value if id == last_id + 1
                // - otherwise emit explicit value
                if (firstInCat) {
                    uint32_t id16 = kv.id & 0xFFFFu;
                    base << "    SDOM_EVENT_" << idname << " = 0x" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << id16 << std::dec << ",";
                } else {
                    if (kv.id == last_id + 1) {
                        base << "    SDOM_EVENT_" << idname << ",";
                    } else {
                        uint32_t id16 = kv.id & 0xFFFFu;
                        base << "    SDOM_EVENT_" << idname << " = 0x" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << id16 << std::dec << ",";
                    }
                }
                baseStr = base.str();

                if (!kv.doc.empty()) {
                    std::string doc = kv.doc;
                    for (char &c : doc) if (c == '\n' || c == '\r') c = ' ';

                    const size_t target_col = 44;
                    size_t baseLen = baseStr.size();
                    size_t pad = (baseLen >= target_col) ? 1 : (target_col - baseLen);
                    ofs << baseStr << std::string(pad, ' ') << " /**< " << doc << " */\n";
                } else {
                    ofs << baseStr << "\n";
                }

                last_id = kv.id;
                firstInCat = false;
            }
        }

        ofs << "    /**\n";
        ofs << "     *  This last event is only for bounding internal arrays\n";
        ofs << "     */\n";
        ofs << "    SDOM_EVENT_LAST    = 0xFFFF,\n\n";
        ofs << "    /* This just makes sure the enum is the size of Uint32 */\n";
        ofs << "    SDOM_EVENT_ENUM_PADDING = 0x7FFFFFFF\n";
        ofs << "} SDOM_EventType;\n\n";

        ofs << "#ifdef __cplusplus\n}\n#endif\n";
        ofs.close();
        std::cout << "[CBindingGenerator] wrote " << outpath.string() << std::endl;
        return true;
    };

    // Primary output (generator-specified directory)
    std::filesystem::path primary = join_path(outputDir, "SDOM_CAPI_Events.h");
    bool ok = write_header(primary);

    // Also write into the repository include path: search upward for a
    // directory containing a top-level CMakeLists.txt and write to
    // REPO_ROOT/include/SDOM/CAPI/SDOM_CAPI_Events.h if found.
    std::filesystem::path cwd = std::filesystem::current_path();
    std::filesystem::path repo_root;
    for (auto p = cwd; ; p = p.parent_path()) {
        if (p == p.parent_path()) break; // reached filesystem root
        if (std::filesystem::exists(p / "CMakeLists.txt")) { repo_root = p; break; }
    }
    if (!repo_root.empty()) {
        std::filesystem::path repo_out = repo_root / "include" / "SDOM" / "CAPI" / "SDOM_CAPI_Events.h";
        // best-effort write; ignore failures
        try { write_header(repo_out); } catch(...) {}
    }

    return ok;
}
