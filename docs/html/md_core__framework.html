<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDOM - Simple SDL Document Object Model: SDOM Core Framework Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDOM - Simple SDL Document Object Model
   </div>
   <div id="projectbrief">A lightweight, extensible Document Object Model for SDL-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_core__framework.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">SDOM Core Framework Design</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1"></a> </p>
<h1><a class="anchor" id="autotoc_md2"></a>
Overview</h1>
<p>The <code>Core</code> object is the central framework of the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> API. It is implemented as a Singleton and is responsible for composing the main SDL loop, error logging/trapping, the Factory, and the EventManager. The Core orchestrates the lifecycle and event flow of the application.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Core Responsibilities</h1>
<ul>
<li>Singleton pattern for global access and lifecycle management</li>
<li>Main SDL loop management</li>
<li>Error logging and trapping</li>
<li>Composition and management of:<ul>
<li>Factory (object/resource creation)</li>
<li>EventManager (event dispatch and handling)</li>
<li>Stage (the root display object)</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
Core Initialization Sequence &amp; Pre-Initialization Configuration</h1>
<p>To ensure proper setup, <code>onInit()</code> should be called <b>after</b> the SDL Video Subsystem (window, renderer, texture) has been created and initialized. This requires that all necessary configuration parameters are provided to Core <b>before</b> initialization begins.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Required Pre-Initialization Parameters:</h2>
<ul>
<li><b>Core (Pixel) Resolution:</b> The logical pixel dimensions for rendering.</li>
<li><b>Initial Window Size:</b> The starting size of the SDL window.</li>
<li><b>Rendering Flags:</b> SDL renderer creation flags (e.g., hardware acceleration, vsync).</li>
<li><b>Presentation Flags:</b> SDL window flags (e.g., resizable, fullscreen).</li>
<li><b>Color Format:</b> Desired pixel format for rendering and textures.</li>
<li><b>Other SDL/graphics options:</b> As needed for your application.</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
Initialization Flow:</h2>
<ol type="1">
<li><b>Configure Core:</b> <br  />
 Pass all required parameters to Core via a configuration struct or initialization method.</li>
<li><b>Create SDL Video Subsystem:</b> <br  />
 Core creates the SDL window, renderer, and main display texture using the provided settings.</li>
<li><b>Call onInit():</b> <br  />
 Once the video subsystem is ready, Core invokes <code>onInit()</code> to allow application-specific initialization (e.g., loading assets, setting up stages).</li>
<li><b>Enter Main Loop:</b> <br  />
 Core proceeds with the main SDL loop, event handling, and rendering.</li>
</ol>
<h2><a class="anchor" id="autotoc_md7"></a>
Example Configuration API:</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CoreConfig {</div>
<div class="line">    <span class="keywordtype">float</span> windowWidth;</div>
<div class="line">    <span class="keywordtype">float</span> windowHeight;</div>
<div class="line">    <span class="keywordtype">float</span> pixelWidth;   <span class="comment">// Virtual width of a single pixel (for logical scaling; can be fractional/non-square)</span></div>
<div class="line">    <span class="keywordtype">float</span> pixelHeight;  <span class="comment">// Virtual height of a single pixel (for logical scaling; can be fractional/non-square)</span></div>
<div class="line">    <span class="keywordtype">bool</span> preserveAspectRatio = <span class="keyword">true</span>;    <span class="comment">// Preserve original aspect ratio when resizing window</span></div>
<div class="line">    <span class="keywordtype">bool</span> allowTextureResize = <span class="keyword">true</span>;     <span class="comment">// Allow texture resolution to change when resizing window</span></div>
<div class="line">    SDL_RendererLogicalPresentation rendererFlags;</div>
<div class="line">    SDL_WindowFlags windowFlags;</div>
<div class="line">    SDL_PixelFormat colorFormat;</div>
<div class="line">    <span class="comment">// ... other options ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Core&amp; core = getCore();</div>
<div class="line">core.configure(CoreConfig{<span class="comment">/* ... */</span>});</div>
<div class="line">core.run(); <span class="comment">// Internally calls onInit() after SDL setup</span></div>
</div><!-- fragment --><p><b>Note:</b> <br  />
 All pre-initialization information must be set before calling <code>run()</code> or starting the main loop. This ensures that the video subsystem is correctly configured and available for all subsequent operations.</p>
<hr  />
<p>To ensure proper setup, <code>onInit()</code> should be called <b>after</b> the SDL Video Subsystem (window, renderer, texture) has been created and initialized. This requires that all necessary configuration parameters are provided to Core <b>before</b> initialization begins.</p>
<h2><a class="anchor" id="autotoc_md9"></a>
Required Pre-Initialization Parameters:</h2>
<ul>
<li><b>Core (Pixel) Resolution:</b> The logical pixel dimensions for rendering.</li>
<li><b>Initial Window Size:</b> The starting size of the SDL window.</li>
<li><b>Rendering Flags:</b> SDL renderer creation flags (e.g., hardware acceleration, vsync).</li>
<li><b>Presentation Flags:</b> SDL window flags (e.g., resizable, fullscreen).</li>
<li><b>Color Format:</b> Desired pixel format for rendering and textures.</li>
<li><b>Other SDL/graphics options:</b> As needed for your application.</li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
Alternative Initialization: JSON Configuration</h2>
<p>In addition to using a configuration struct, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> Core can be initialized using a JSON string or by loading configuration from a JSON file. This approach allows for flexible, data-driven setup and easier integration with external tools or scripting environments.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Example API:</h3>
<div class="fragment"><div class="line">Core&amp; core = getCore();</div>
<div class="line">core.configureFromJson(R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">    &quot;core&quot;: {</span></div>
<div class="line"><span class="stringliteral">        &quot;windowWidth&quot;: 1280.0,</span></div>
<div class="line"><span class="stringliteral">        &quot;windowHeight&quot;: 720.0,</span></div>
<div class="line"><span class="stringliteral">        &quot;pixelWidth&quot;: 2.0,</span></div>
<div class="line"><span class="stringliteral">        &quot;pixelHeight&quot;: 2.0,</span></div>
<div class="line"><span class="stringliteral">        &quot;allowTextureResize&quot;: false,</span></div>
<div class="line"><span class="stringliteral">        &quot;preserveAspectRatio&quot;: true,</span></div>
<div class="line"><span class="stringliteral">        &quot;rendererFlags&quot;: &quot;SDL_LOGICAL_PRESENTATION_LETTERBOX&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;windowFlags&quot;: &quot;SDL_WINDOW_FULLSCREEN | SDL_WINDOW_RESIZABLE&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;colorFormat&quot;: &quot;SDL_PIXELFORMAT_RGBA8888&quot;</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">})&quot;);</span></div>
<div class="line"><span class="stringliteral">core.run();</span></div>
</div><!-- fragment --><p> Or, loading from a file: </p><div class="fragment"><div class="line">core.configureFromJsonFile(<span class="stringliteral">&quot;config/core_config.json&quot;</span>);</div>
<div class="line">core.run();</div>
</div><!-- fragment --><p><b>Note:</b> <br  />
 All pre-initialization information must be set before calling <code>run()</code> or starting the main loop. This ensures that the video subsystem is correctly configured and available for all subsequent operations.</p>
<hr  />
<p>Let me know if you want this added to a specific section, or if youâ€™d like to expand on configuration struct details or error handling for initialization!</p>
<h1><a class="anchor" id="autotoc_md13"></a>
Primary Callbacks</h1>
<p>The Core exposes the following virtual callback methods, which are invoked during the application lifecycle:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span>  onInit () <span class="keyword">override</span>;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onQuit () <span class="keyword">override</span>;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onUpdate (<span class="keywordtype">float</span> fElapsedTime) = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onEvent (<span class="keyword">const</span> Event &amp;event) = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onRender () = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span>  onUnitTest ();</div>
</div><!-- fragment --><ul>
<li><code>onInit()</code>: Called during initialization.</li>
<li><code>onQuit()</code>: Called during shutdown/cleanup.</li>
<li><code>onUpdate(float fElapsedTime)</code>: Called every frame to update logic.</li>
<li><code>onEvent(const Event &amp;event)</code>: Called for each incoming event.</li>
<li><code>onRender()</code>: Called every frame to render the stage.</li>
<li><code>onUnitTest()</code>: Called to run unit tests.</li>
</ul>
<p>Each callback is designed to interact directly with the single Stage object, which represents the root of the display hierarchy.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Hook &amp; Callback Registration</h1>
<p>To support extensibility across multiple languages (C++, Python, Rust, etc.), the Core framework provides a hook/callback registration system for all primary lifecycle and event methods. Instead of requiring inheritance, users can register function pointers, std::function, or language bindings for each event:</p>
<ul>
<li>Initialization: <code>registerOnInit(std::function&lt;bool()&gt;)</code></li>
<li>Quit: <code>registerOnQuit(std::function&lt;void()&gt;)</code></li>
<li>Update: <code>registerOnUpdate(std::function&lt;void(float)&gt;)</code></li>
<li>Event: <code>registerOnEvent(std::function&lt;void(const Event&amp;)&gt;)</code></li>
<li>Render: <code>registerOnRender(std::function&lt;void()&gt;)</code></li>
<li>Unit Test: <code>registerOnUnitTest(std::function&lt;bool()&gt;)</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Example (C++)</h2>
<div class="fragment"><div class="line">Core core;</div>
<div class="line">core.registerOnInit([]() { <span class="comment">/* ... */</span> <span class="keywordflow">return</span> <span class="keyword">true</span>; });</div>
<div class="line">core.registerOnQuit([]() { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnUpdate([](<span class="keywordtype">float</span> dt) { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnEvent([](<span class="keyword">const</span> Event&amp; e) { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnRender([]() { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnUnitTest([]() { <span class="comment">/* ... */</span> <span class="keywordflow">return</span> <span class="keyword">true</span>; });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Example (Python/Rust)</h2>
<p>Bindings can expose similar registration functions, allowing users to set hooks in their language of choice.</p><ul>
<li>Core stores each hook as a function object.</li>
<li>At each lifecycle stage, Core checks for a registered hook and invokes it if present.</li>
<li>Inheritance remains an option for C++ users, but is not required for other languages.</li>
</ul>
<h1><a class="anchor" id="autotoc_md17"></a>
Global Accessor Functions</h1>
<p>The <a class="el" href="SDOM_8hpp.html" title="Common include for SDOM-based projects. Defines macros and utilities.">SDOM.hpp</a> header may define a set of global functions within the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> namespace to provide convenient access to key framework components:</p><ul>
<li><code>getCore()</code></li>
<li><code>getStage()</code></li>
<li><code>getWindow()</code></li>
<li><code>getRenderer()</code></li>
<li>...etc.</li>
</ul>
<p>These global accessors allow users to retrieve singleton or shared instances of major subsystems without directly referencing their implementation details. This pattern simplifies initialization and integration, especially for scripting and cross-language bindings.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Example Usage (with global accessor)</h2>
<div class="fragment"><div class="line">Core&amp; core = getCore();</div>
<div class="line">core.registerOnInit([]() {</div>
<div class="line">    <span class="comment">// Custom initialization</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line">core.registerOnQuit([]() {</div>
<div class="line">    <span class="comment">// Cleanup logic</span></div>
<div class="line">});</div>
<div class="line">core.registerOnUpdate([](<span class="keywordtype">float</span> dt) {</div>
<div class="line">    <span class="comment">// Game logic</span></div>
<div class="line">});</div>
<div class="line">core.registerOnEvent([](<span class="keyword">const</span> Event &amp;event) {</div>
<div class="line">    <span class="comment">// Handle events</span></div>
<div class="line">});</div>
<div class="line">core.registerOnRender([]() {</div>
<div class="line">    <span class="comment">// Render stage</span></div>
<div class="line">});</div>
<div class="line">core.registerOnUnitTest([]() {</div>
<div class="line">    <span class="comment">// Run tests</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    core.run();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md19"></a>
Composition Diagram</h1>
<div class="fragment"><div class="line">+-------------------+</div>
<div class="line">|      Core         |</div>
<div class="line">|-------------------|</div>
<div class="line">| - Factory         |</div>
<div class="line">| - EventManager    |</div>
<div class="line">| - Stage           |</div>
<div class="line">| - ErrorLogger     |</div>
<div class="line">+-------------------+</div>
<div class="line">        | (owns)</div>
<div class="line">        v</div>
<div class="line">+-------------------+</div>
<div class="line">|     SDL Loop      |</div>
<div class="line">+-------------------+</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
Extensibility &amp; Singleton Pattern</h1>
<p>The Core object is implemented as a singleton, ensuring a single point of control for the application's lifecycle, event management, and resource handling. Despite the singleton pattern, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> remains highly extensible:</p>
<ul>
<li>Hooks, eventListeners, and class-based inheritance allow users to customize behavior without modifying the Core implementation.</li>
<li>Plugins and modules can register their own callbacks or listeners with the singleton Core instance.</li>
<li>The singleton ensures global access and coordination, while extensibility is achieved through registration APIs and listener patterns.</li>
</ul>
<p>This design balances centralized control with flexible extension points for applications and language bindings.</p>
<h1><a class="anchor" id="autotoc_md21"></a>
EventListener Support</h1>
<p>In addition to direct hook/callback registration, the Core framework can support external integration through eventListeners. This approach allows users to attach listener objects or functions to specific lifecycle and event types, enabling modular and decoupled handling of application events.</p>
<ul>
<li>Listeners can subscribe to events such as Init, Quit, Update, Render, and custom events.</li>
<li>The Core maintains a list of listeners for each event type and notifies them when the event occurs.</li>
<li>Listeners can be implemented as objects with event-handling methods, or as standalone functions.</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
Example (C)</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onInit() { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onQuit() { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onUpdate(<span class="keywordtype">float</span> dt) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onEvent(<span class="keyword">const</span> Event&amp; e) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onRender() { <span class="comment">/* ... */</span> }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Core&amp; core = <a class="code hl_function" href="namespaceSDOM.html#ae65864505926b5378f1fcd94afe1aa06">SDOM::getCore</a>();</div>
<div class="line">    CoreConfig config;</div>
<div class="line">    config.windowWidth = 1280;</div>
<div class="line">    config.windowHeight = 960;</div>
<div class="line">    config.pixelWidth = 2.0;</div>
<div class="line">    config.pixelHeight = 2.0;</div>
<div class="line">    config.allowTextureResize = <span class="keyword">true</span>,</div>
<div class="line">    config.preserveAspectRatio = <span class="keyword">true</span>,</div>
<div class="line">    config.renderFlags = SDL_LOGICAL_PRESENTATION_LETTERBOX;</div>
<div class="line">    config.windowFlags = SDL_WINDOW_FULLSCREEN | SDL_WINDOW_RESIZABLE;</div>
<div class="line">    condig.colorFormat = SDL_PIXELFORMAT_RGBA8888;</div>
<div class="line">    core.configure(config);</div>
<div class="line"> </div>
<div class="line">    core.addEventListener(EventType::Init, []() { onInit(); });</div>
<div class="line">    core.addEventListener(EventType::Quit, []() { onQuit(); });</div>
<div class="line">    core.addEventListener(EventType::Update, [](<span class="keywordtype">float</span> dt) { onUpdate(dt); });</div>
<div class="line">    core.addEventListener(EventType::Event, [](<span class="keyword">const</span> Event&amp; e) { onEvent(e); });</div>
<div class="line">    core.addEventListener(EventType::Render, []() { onRender(); });</div>
<div class="line"> </div>
<div class="line">    core.run();</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceSDOM_html_ae65864505926b5378f1fcd94afe1aa06"><div class="ttname"><a href="namespaceSDOM.html#ae65864505926b5378f1fcd94afe1aa06">SDOM::getCore</a></div><div class="ttdeci">static Core &amp; getCore()</div><div class="ttdef"><b>Definition</b> SDOM.hpp:138</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md23"></a>
Benefits</h2>
<ul>
<li>Enables multiple listeners for the same event type</li>
<li>Decouples event handling from the Core and main application logic</li>
<li>Facilitates plugin architectures and modular extensions</li>
</ul>
<h1><a class="anchor" id="autotoc_md24"></a>
Registering Custom Stage Objects</h1>
<p>Custom Stage objects can be registered and managed through the Factory system, just like any other DOM object. To use a custom Stage:</p>
<ol type="1">
<li><b>Inherit from the Stage class to define your custom Stage type.</b></li>
<li><b>Register the custom Stage type with the Factory.</b></li>
<li><b>Create the Stage instance via the Factory.</b></li>
<li><b>Register the Stage with the Core using a unique name.</b></li>
<li><b>Switch to the custom Stage using <code>Core::setStage(name)</code>.</b></li>
</ol>
<p>This approach ensures consistent resource management and makes it easy to extend <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> with new scene types or behaviors.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Register custom Stage type with Factory</span></div>
<div class="line">factory-&gt;registerType&lt;CustomStage&gt;(<span class="stringliteral">&quot;CustomStage&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a custom Stage instance</span></div>
<div class="line">resource_ptr&lt;Stage&gt; myStage = factory-&gt;create&lt;CustomStage&gt;(initStruct);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the Stage with Core</span></div>
<div class="line">core.registerStage(<span class="stringliteral">&quot;myCustomStage&quot;</span>, myStage);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Switch to the custom Stage</span></div>
<div class="line">core.setStage(<span class="stringliteral">&quot;myCustomStage&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md26"></a>
Integration Methods Summary</h1>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> Core supports three primary methods for application setup and event handling:</p>
<ol type="1">
<li><b>Callback/Hook Registration</b><ul>
<li>Use <code>registerOnInit()</code>, <code>registerOnQuit()</code>, etc. to set function hooks for lifecycle and event methods.</li>
<li>Ideal for scripting languages, functional programming, and dynamic runtime configuration.</li>
</ul>
</li>
<li><b>EventListener Pattern</b><ul>
<li>Attach listener objects or functions to specific event types using <code>addEventListener()</code>.</li>
<li>Enables modular, decoupled event handling and plugin architectures.</li>
<li>Supports multiple listeners per event.</li>
</ul>
</li>
<li><b>Class-Based Inheritance</b><ul>
<li>Inherit from the Stage class and override virtual methods (<code>onInit()</code>, <code>onUpdate()</code>, etc.).</li>
<li>Familiar to C++ developers and suitable for static, strongly-typed applications.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md27"></a>
Flexibility &amp; Use Cases</h2>
<ul>
<li>Callback registration is best for cross-language bindings and dynamic configuration.</li>
<li>EventListeners are ideal for extensible, plugin-based systems.</li>
<li>Class-based inheritance provides a traditional OOP approach for C++ and similar languages.</li>
</ul>
<p>Applications can mix and match these methods as needed, ensuring <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> remains flexible and accessible to a wide range of development styles and languages.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Performance Considerations</h1>
<ul>
<li>The difference in performance between the three setup types (callback registration, eventListeners, class-based inheritance) is generally negligible for most applications.</li>
<li><b>Direct callback/hook registration</b> is likely the fastest, as it involves a single function call per event and is well-suited for functional programming or C language bindings.</li>
<li><b>EventListener pattern</b> may introduce minor overhead if there are many listeners attached to the same event, as each must be iterated and invoked. This overhead is typically small unless the listener count is very high.</li>
<li><b>Class-based inheritance</b> performance is similar to direct callbacks, as virtual method dispatch is efficient in modern C++ compilers.</li>
</ul>
<p>For most use cases, the choice should be based on flexibility, language integration, and architectural needs rather than raw performance.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Single Stage, Single Window Rationale</h1>
<p>A previous iteration of the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> API supported multiple windows and stages, but this introduced significant complexity:</p><ul>
<li>Each window/stage required separate initialization of external resources (bitmaps, fonts, etc).</li>
<li>Window placement is unreliable or unsupported on many OSes (e.g., Wayland, Windows).</li>
<li>Managing multiple renderers and resource lifetimes increases maintenance burden.</li>
</ul>
<p>For these reasons, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> now uses a single stage, single window framework. SDL window/renderer/texture management is encapsulated within the Core object, ensuring centralized control and simplified resource management.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
Overriding the Default Stage</h1>
<p>If a user defines multiple Stage objects or wishes to override the default stage:</p><ul>
<li>The Core should maintain a single active Stage instance at any time.</li>
<li>When a new Stage is set, the previous (default) Stage should be destroyed or dereferenced, and all rendering/event logic should be redirected to the new Stage.</li>
<li>The API should provide a method such as <code>setStage(Stage*)</code> or <code>replaceStage(Stage*)</code> to handle this transition cleanly.</li>
<li>Only one Stage should be active and connected to the window/renderer at a time; additional Stage objects should remain inactive until explicitly set as the current stage.</li>
</ul>
<p>This approach maintains the simplicity and reliability of the single stage/single window model, while allowing advanced users to swap or override the Stage if needed.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Multiple Stages as Scenes</h1>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> can support multiple Stage objects, but only one Stage is active at any given time. This enables a flexible scene management system:</p><ul>
<li>Each Stage instance can represent a different "Scene" (e.g., menu, gameplay, pause screen).</li>
<li>The Core maintains a reference to the currently active Stage.</li>
<li>Users can create, store, and switch between Stage objects using an API such as <code>setActiveStage(Stage*)</code> or <code>activateScene(Stage*)</code>.</li>
<li>When a new Stage is activated, the previous Stage is deactivated (but not destroyed), allowing for fast scene transitions and state preservation.</li>
<li>All rendering, event handling, and updates are directed to the active Stage.</li>
</ul>
<p>This approach combines the simplicity of a single window with the flexibility of multi-scene applications, making <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> suitable for games, interactive apps, and complex UIs.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Window Resizing &amp; Texture Resolution</h1>
<p>Window resizing introduces several design considerations, especially when supporting multiple stages or scenes with their own textures and renderers:</p>
<ul>
<li><b>Texture Resolution Adjustment:</b> <br  />
 When the window is resized, you can choose to:<ul>
<li>Dynamically recreate the render target texture to match the new window size (may require reloading or scaling assets).</li>
<li>Keep the texture resolution fixed and scale/stretch the rendered output to fit the window.</li>
</ul>
</li>
<li><b>Rendering Strategies:</b> <br  />
<ul>
<li><b>Stretch:</b> Scale the rendered texture to fill the window, which may distort aspect ratio.</li>
<li><b>Letterbox/Pillarbox:</b> Maintain aspect ratio by adding black bars (letterboxing) if the window size does not match the texture resolution.</li>
<li><b>Dynamic Layout:</b> Adjust DOM display objects and UI layout to fit the new window size, which may require recalculating positions and sizes.</li>
</ul>
</li>
<li><b>Complexity with Multiple Stages:</b> <br  />
 If each Stage has its own texture and renderer, resizing the window means:<ul>
<li>The active Stage must update its renderer and texture to match the new window size.</li>
<li>Inactive Stages may need to store their preferred resolution and update when activated.</li>
<li>DOM display objects must be aware of the current renderer and texture, and may need to adjust their layout or assets accordingly.</li>
</ul>
</li>
<li><b>Recommended Approach:</b> <br  />
<ul>
<li>Compose the SDL Video Subsystem within the Core object for centralized management.</li>
<li>Provide hooks/callbacks (e.g., <code>onWindowResize(int width, int height)</code>) for Stages and DOM objects to respond to window size changes.</li>
<li>Decide on a default rendering strategy (stretch, letterbox, dynamic layout) and allow applications to override as needed.</li>
<li>Document the implications of window resizing for asset management, texture recreation, and UI layout.</li>
</ul>
</li>
</ul>
<p>This approach balances centralized control with flexibility, ensuring that window resizing is handled consistently and efficiently across all stages and display objects.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
Shared Display Texture for Stages</h1>
<p>While <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> supports multiple Stage objects for scene management, it is not necessary for each Stage to maintain its own main display texture. If all Stages share the same pixel dimensions as the main display managed by Core, they can simply use the same CoreTexture for rendering.</p>
<ul>
<li>This approach reduces memory usage and simplifies resource management.</li>
<li>All Stages render to the same texture, ensuring consistent output and easy scene transitions.</li>
<li>If a Stage requires offscreen rendering or special effects, it can create its own auxiliary textures as needed, but the main display texture remains shared.</li>
</ul>
<p>By default, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> encourages sharing the CoreTexture among all Stages unless an application has specific requirements for unique render targets per scene.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Stages as Game States or Modes</h1>
<p>Supporting multiple Stage objects in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> enables the framework to represent different states or modes within an application or game. For example:</p>
<ul>
<li><b>Main Menu Stage:</b> Handles menu navigation, UI, and input for starting or exiting the game.</li>
<li><b>Settings Stage:</b> Manages configuration options, audio/video settings, and user preferences.</li>
<li><b>Gameplay Stage:</b> Contains the main game logic, rendering, and event handling for active play.</li>
<li><b>Pause Stage:</b> Displays pause menu, overlays, or temporary dialogs during gameplay.</li>
</ul>
<p>Each Stage encapsulates its own display hierarchy, event handling, and logic, allowing for clean separation of concerns and easy transitions between states. The Core manages which Stage is currently active, enabling fast and reliable switching between modes.</p>
<p>This design makes <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> well-suited for games and interactive applications that require multiple distinct states or scenes.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Changing the Active Stage</h1>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> provides a simple API for switching the active Stage (scene) by name:</p>
<div class="fragment"><div class="line">Core::setStage(std::string name);</div>
</div><!-- fragment --><ul>
<li>This call sets the Stage identified by its unique name as the active scene.</li>
<li>All rendering, event handling, and updates are redirected to the newly activated Stage.</li>
<li>The previous Stage is deactivated but remains available for future use or state preservation.</li>
<li>This approach enables fast and reliable scene transitions, making it easy to implement menus, gameplay, settings, and other modes.</li>
</ul>
<p>Example usage: </p><div class="fragment"><div class="line">Core&amp; core = <a class="code hl_function" href="namespaceSDOM.html#ae65864505926b5378f1fcd94afe1aa06">SDOM::getCore</a>();</div>
<div class="line">core.setStage(<span class="stringliteral">&quot;gameplay&quot;</span>); <span class="comment">// Switch to the gameplay scene</span></div>
</div><!-- fragment --><p>This API keeps scene management simple and intuitive for developers.</p>
<hr  />
<p> This document will be expanded as the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> Core framework evolves. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<footer>
  <a href="https://github.com/warte67/SDOM">Back to SDOM on GitHub</a>
</footer>