<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDOM - Simple SDL Document Object Model: Display Object Anchoring System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDOM - Simple SDL Document Object Model
   </div>
   <div id="projectbrief">A lightweight, extensible Document Object Model for SDL-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2display__object__anchoring.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Display Object Anchoring System</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md44"></a>(Updated September 2, 2025)</p>
<p>The Display Object Anchoring System defines layout in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> by anchoring each of a child’s four edges to any of nine reference points on its parent (top/middle/bottom × left/center/right). Each edge has its own anchor and local offset (left_, right_, top_, bottom_), so objects can pin, center, or stretch asymmetrically as parents move or resize. World-space geometry is derived from edges—width = right − left and height = bottom − top—yielding predictable, resolution‑independent layout.</p>
<p>When anchors change, the system preserves visual stability. Changing an anchor recalculates only the corresponding local offset so the world position of that edge does not move. The same invariant powers drag‑and‑drop and reparenting: record the world edges, apply the new parent/anchors, then resolve new local offsets from the new parent’s anchor references. This makes interactive editing and runtime scene changes smooth, enabling fixed margins, edge‑to‑edge stretching, and center‑based alignment without jumps.</p>
<p>The API exposes clear accessors for per‑edge anchors and offsets, with sensible defaults that keep existing content working (top‑left if unspecified). Configuration can be supplied in code, via Lua scripts during initialization or at runtime, or from external data; names map directly onto the nine‑point grid with convenient aliases. Because anchoring is edge‑based and hierarchical, complex layouts compose naturally: nested children inherit motion from ancestors yet retain precise rules for how each edge follows the parent. The result is a compact, robust model that behaves well under resizing, scaling, and scene swaps.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Anchor Naming Conventions</h2>
<ul>
<li>Anchor points are represented as enums in code: <code>AnchorPoint::TOP_LEFT</code>, <code>AnchorPoint::TOP_CENTER</code>, <code>AnchorPoint::TOP_RIGHT</code>, <code>AnchorPoint::MIDDLE_LEFT</code>, <code>AnchorPoint::MIDDLE_CENTER</code>, <code>AnchorPoint::MIDDLE_RIGHT</code>, <code>AnchorPoint::BOTTOM_LEFT</code>, <code>AnchorPoint::BOTTOM_CENTER</code>, <code>AnchorPoint::BOTTOM_RIGHT</code>.</li>
<li>In Lua or config, these may be written as strings: <code>"top_left"</code>, <code>"middle_center"</code>, etc. The mapping is direct and bindings accept either the enum or a string alias.</li>
</ul>
<h2><a class="anchor" id="autotoc_md46"></a>
Edge-Based Layout</h2>
<ul>
<li>Each display object tracks its edges: <code>left_</code>, <code>right_</code>, <code>top_</code>, <code>bottom_</code>.</li>
<li>Each edge can have its own anchor point, allowing for asymmetric anchoring.</li>
<li>All movement, resizing, and anchor changes are performed via edge setters/getters: <code>setLeft</code>, <code>setRight</code>, <code>setTop</code>, <code>setBottom</code>, <code>getLeft</code>, <code>getRight</code>, <code>getTop</code>, <code>getBottom</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md47"></a>
Position and Size Calculation</h2>
<ul>
<li>The world position of each edge is calculated as:<ul>
<li><code>getLeft() = parent_anchor_x + left_</code></li>
<li><code>getRight() = parent_anchor_x + right_</code></li>
<li><code>getTop() = parent_anchor_y + top_</code></li>
<li><code>getBottom() = parent_anchor_y + bottom_</code></li>
<li>Where <code>parent_anchor_x</code> and <code>parent_anchor_y</code> are determined by the parent's anchor reference for the respective edge.</li>
</ul>
</li>
<li><b>Width and height are always computed as:</b><ul>
<li><code>width = getRight() - getLeft()</code></li>
<li><code>height = getBottom() - getTop()</code></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md48"></a>
Anchor Accessors/Mutators</h2>
<ul>
<li>Use the following API methods for anchor management:<ul>
<li><code>setAnchorLeft(AnchorPoint ap)</code></li>
<li><code>setAnchorRight(AnchorPoint ap)</code></li>
<li><code>setAnchorTop(AnchorPoint ap)</code></li>
<li><code>setAnchorBottom(AnchorPoint ap)</code></li>
<li><code>getAnchorLeft()</code>, <code>getAnchorRight()</code>, <code>getAnchorTop()</code>, <code>getAnchorBottom()</code></li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md49"></a>
Changing Anchor Points</h2>
<ul>
<li>When an anchor is changed, the corresponding local offset (<code>left_</code>, <code>right_</code>, etc.) is recalculated so the world position of the edge does not move.</li>
<li>Only the local offset for the changed anchor is updated; other edges remain unchanged unless their anchors are also changed.</li>
</ul>
<h2><a class="anchor" id="autotoc_md50"></a>
Drag-and-Drop and Reparenting</h2>
<ul>
<li><b>When reparenting or during drag-and-drop:</b><ul>
<li>Record the world positions of all edges (<code>getLeft()</code>, <code>getRight()</code>, <code>getTop()</code>, <code>getBottom()</code>) before changing parent or anchor.</li>
<li>After changing parent or anchor, recalculate all local offsets using the new parent's anchor references and the recorded world positions.</li>
</ul>
</li>
<li>This ensures the object's position and size remain correct regardless of anchor configuration or parent changes.</li>
</ul>
<h2><a class="anchor" id="autotoc_md51"></a>
Summary</h2>
<ul>
<li>The anchoring system is now robust, edge-based, and supports asymmetric anchors.</li>
<li>All geometry calculations and API methods have been updated to reflect this design. </li>
</ul>
<h1><a class="anchor" id="autotoc_md52"></a>
Overview</h1>
<p>This document describes the anchor point system for positioning and sizing display objects in the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> API. Anchoring enables flexible, responsive layouts by allowing each display object to reference its position and size to any of nine anchor points on its parent.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Anchor Points</h1>
<p>Each display object can specify anchor points for its four edges (left/X, top/Y, right/width, bottom/height) in relation to its parent. The nine possible anchor points are:</p>
<ul>
<li><code>top_left</code></li>
<li><code>top_center</code></li>
<li><code>top_right</code></li>
<li><code>middle_left</code></li>
<li><code>middle_center</code></li>
<li><code>middle_right</code></li>
<li><code>bottom_left</code></li>
<li><code>bottom_center</code></li>
<li><code>bottom_right</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md54"></a>
Reversed versions for user convenience</h2>
<ul>
<li><code>center_middle</code></li>
<li><code>right_middle</code></li>
<li><code>left_middle</code></li>
<li><code>center_top</code></li>
<li><code>right_top</code></li>
<li><code>left_top</code></li>
<li><code>center_bottom</code></li>
<li><code>right_bottom</code></li>
<li><code>left_bottom</code></li>
</ul>
<p>For convenience, aliases like <code>left</code>, <code>center</code>, <code>right</code>, <code>top</code>, <code>middle</code>, and <code>bottom</code> are also supported.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Lua Interface</h1>
<p>Anchor points are typically provided from Lua modules or from code. For configuration files, prefer a small Lua module that returns a table. If anchor fields are omitted, anchors default to <code>top_left</code>.</p>
<p>Example Lua module (<code>config/layout.lua</code>):</p>
<div class="fragment"><div class="line">return {</div>
<div class="line">    x = 10,</div>
<div class="line">    y = 10,</div>
<div class="line">    width = -10,</div>
<div class="line">    height = -10,</div>
<div class="line">    child_anchor_x = &quot;left&quot;,</div>
<div class="line">    child_anchor_width = &quot;right&quot;,</div>
<div class="line">    child_anchor_y = &quot;top&quot;,</div>
<div class="line">    child_anchor_height = &quot;bottom&quot;,</div>
<div class="line">}</div>
</div><!-- fragment --><p>C++ (Sol2) usage to load the module and configure an object:</p>
<div class="fragment"><div class="line">sol::state&amp; lua = core.getLua();</div>
<div class="line">sol::table cfg = lua.require&lt;sol::table&gt;(<span class="stringliteral">&quot;config.layout&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> childAnchorX = cfg[<span class="stringliteral">&quot;child_anchor_x&quot;</span>].get_or&lt;std::string&gt;(<span class="stringliteral">&quot;top_left&quot;</span>);</div>
<div class="line">AnchorPoint ap = parseAnchor(childAnchorX);</div>
<div class="line">child-&gt;setAnchorLeft(ap);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md56"></a>
Position and Size Calculation</h1>
<ul>
<li><b>X (left edge):</b> Anchored to the specified parent anchor point, plus offset.</li>
<li><b>Y (top edge):</b> Anchored to the specified parent anchor point, plus offset.</li>
<li><b>Width (right edge):</b> Anchored to the specified parent anchor point, minus offset.</li>
<li><b>Height (bottom edge):</b> Anchored to the specified parent anchor point, minus offset.</li>
</ul>
<p>For example: </p><div class="fragment"><div class="line">child.x = parent.anchor_x + offset_x</div>
<div class="line">child.y = parent.anchor_y + offset_y</div>
<div class="line">child.width = parent.anchor_width - offset_width</div>
<div class="line">child.height = parent.anchor_height - offset_height</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md57"></a>
Changing Anchor Points</h1>
<p>When an anchor point is changed, the offset is recalculated so the display object remains visually in the same position and size. This ensures a smooth user experience and prevents layout jumps.</p>
<h1><a class="anchor" id="autotoc_md58"></a>
Hierarchical Anchoring</h1>
<p>Anchor calculations are recursive: each display object references its parent, which may itself be anchored to its own parent, up to the stage. This enables complex, nested layouts.</p>
<h1><a class="anchor" id="autotoc_md59"></a>
Backward Compatibility &amp; Migration</h1>
<p>Existing code that sets anchors programmatically remains compatible. Configuration files that used JSON should be converted to Lua modules (small one-to-one mappings) — see the Migration note below.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Benefits</h1>
<ul>
<li>Flexible, responsive layouts</li>
<li>Easy margin and stretching logic</li>
<li>Consistent positioning and sizing</li>
<li>Backward compatibility</li>
</ul>
<h1><a class="anchor" id="autotoc_md61"></a>
Example Use Cases</h1>
<ul>
<li>Center a child object within its parent</li>
<li>Stretch a child object with margins as the parent resizes</li>
<li>Align a child to any edge or corner of its parent</li>
</ul>
<hr  />
<p>This anchor system makes <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> display objects highly flexible and professional, supporting modern UI layout needs.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md64"></a>
Anchoring Diagrams</h1>
<h2><a class="anchor" id="autotoc_md65"></a>
1) Parent Anchor Grid and Child Edge Anchors</h2>
<p>SVG (static image): <img src="diagrams/display_object_anchoring/diagram-01.svg" alt="Anchors Grid" style="pointer-events: none;" class="inline"/></p>
<details >
<summary >
View Mermaid source</summary>
<p></p>
<div class="fragment"><div class="line"> -norender</div>
<div class="line">%% Parent has 9 anchors; child edges reference any of them with offsets</div>
<div class="line">flowchart TB</div>
<div class="line">    classDef parent fill:#eef7ff,stroke:#4a90e2,color:#1a3b5d</div>
<div class="line">    classDef anchor fill:#fff8e6,stroke:#f0ad4e,color:#5a4500</div>
<div class="line">    classDef child  fill:#f7fff0,stroke:#7bb661,color:#234d20</div>
<div class="line"> </div>
<div class="line">    subgraph P[&quot;Parent (9-point anchor grid)&quot;]</div>
<div class="line">        direction TB</div>
<div class="line">        %% Top row</div>
<div class="line">        TL[&quot;top_left&quot;]:::anchor --&gt; TC[&quot;top_center&quot;]:::anchor --&gt; TR[&quot;top_right&quot;]:::anchor</div>
<div class="line">        %% Middle row</div>
<div class="line">        ML[&quot;middle_left&quot;]:::anchor --&gt; MC[&quot;middle_center&quot;]:::anchor --&gt; MR[&quot;middle_right&quot;]:::anchor</div>
<div class="line">        %% Bottom row</div>
<div class="line">        BL[&quot;bottom_left&quot;]:::anchor --&gt; BC[&quot;bottom_center&quot;]:::anchor --&gt; BR[&quot;bottom_right&quot;]:::anchor</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph C[&quot;Child (edges + local offsets)&quot;]</div>
<div class="line">        direction TB</div>
<div class="line">        L[&quot;Left edge\nleft_&quot;]:::child</div>
<div class="line">        T[&quot;Top edge\ntop_&quot;]:::child</div>
<div class="line">        R[&quot;Right edge\nright_&quot;]:::child</div>
<div class="line">        B[&quot;Bottom edge\nbottom_&quot;]:::child</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    %% Example anchoring links (illustrative)</div>
<div class="line">    L -. anchored to .-&gt; ML</div>
<div class="line">    T -. anchored to .-&gt; TC</div>
<div class="line">    R -. anchored to .-&gt; MR</div>
<div class="line">    B -. anchored to .-&gt; BC</div>
<div class="line"> </div>
<div class="line">    %% Notes (rendering might ignore comments in some mmdc versions)</div>
</div><!-- fragment --><p></p>
</details>
<p>Key idea: each edge uses its own parent anchor reference plus a local offset; width/height derive from right-left and bottom-top.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
2) Anchor Change Recalculation (No Visual Jump)</h2>
<p>SVG (static image): <img src="diagrams/display_object_anchoring/diagram-02.svg" alt="Anchor Change Flow" style="pointer-events: none;" class="inline"/></p>
<details >
<summary >
View Mermaid source</summary>
<p></p>
<div class="fragment"><div class="line"> -norender</div>
<div class="line">sequenceDiagram</div>
<div class="line">    autonumber</div>
<div class="line">    participant User as API Caller</div>
<div class="line">    participant Child as DisplayObject</div>
<div class="line">    participant Parent as Parent</div>
<div class="line">    participant Layout as Layout/Anchoring</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;Child: setAnchorLeft(newAp)</div>
<div class="line">    Child-&gt;&gt;Layout: request anchor change</div>
<div class="line">    Layout-&gt;&gt;Parent: get parent_anchor_x for newAp</div>
<div class="line">    Layout-&gt;&gt;Child: get current world edges\n(getLeft/Right/Top/Bottom)</div>
<div class="line">    Note over Layout,Child: Recalculate only the affected local offset\nso the world edge stays fixed</div>
<div class="line">    Layout--&gt;&gt;Child: left_ = world_left - parent_anchor_x</div>
<div class="line">    Child--&gt;&gt;User: done (no visual jump)</div>
</div><!-- fragment --><p></p>
</details>
<p>This flow illustrates the invariant maintained during anchor changes: the world edge position remains the same while only the corresponding local offset is updated.</p>
<h1><a class="anchor" id="autotoc_md67"></a>
Anchor helpers &amp; parsing</h1>
<p>Bindings accept both enumerated values and string names. A small C++ helper simplifies mapping user-facing strings to enums; expose this to Lua so scripts can use readable names.</p>
<div class="fragment"><div class="line"><span class="comment">// simple mapping helper</span></div>
<div class="line">AnchorPoint parseAnchor(<span class="keyword">const</span> std::string &amp;s) {</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> std::unordered_map&lt;std::string, AnchorPoint&gt; map = {</div>
<div class="line">        {<span class="stringliteral">&quot;top_left&quot;</span>, AnchorPoint::TOP_LEFT}, {<span class="stringliteral">&quot;left_top&quot;</span>, AnchorPoint::TOP_LEFT}, {<span class="stringliteral">&quot;left&quot;</span>, AnchorPoint::TOP_LEFT},</div>
<div class="line">        {<span class="stringliteral">&quot;top_center&quot;</span>, AnchorPoint::TOP_CENTER}, {<span class="stringliteral">&quot;center_top&quot;</span>, AnchorPoint::TOP_CENTER}, {<span class="stringliteral">&quot;center&quot;</span>, AnchorPoint::TOP_CENTER},</div>
<div class="line">        {<span class="stringliteral">&quot;top_right&quot;</span>, AnchorPoint::TOP_RIGHT}, {<span class="stringliteral">&quot;right_top&quot;</span>, AnchorPoint::TOP_RIGHT}, {<span class="stringliteral">&quot;right&quot;</span>, AnchorPoint::TOP_RIGHT},</div>
<div class="line">        {<span class="stringliteral">&quot;middle_left&quot;</span>, AnchorPoint::MIDDLE_LEFT}, {<span class="stringliteral">&quot;left_middle&quot;</span>, AnchorPoint::MIDDLE_LEFT},</div>
<div class="line">        {<span class="stringliteral">&quot;middle_center&quot;</span>, AnchorPoint::MIDDLE_CENTER}, {<span class="stringliteral">&quot;center_middle&quot;</span>, AnchorPoint::MIDDLE_CENTER},</div>
<div class="line">        {<span class="stringliteral">&quot;middle_right&quot;</span>, AnchorPoint::MIDDLE_RIGHT}, {<span class="stringliteral">&quot;right_middle&quot;</span>, AnchorPoint::MIDDLE_RIGHT},</div>
<div class="line">        {<span class="stringliteral">&quot;bottom_left&quot;</span>, AnchorPoint::BOTTOM_LEFT}, {<span class="stringliteral">&quot;left_bottom&quot;</span>, AnchorPoint::BOTTOM_LEFT},</div>
<div class="line">        {<span class="stringliteral">&quot;bottom_center&quot;</span>, AnchorPoint::BOTTOM_CENTER}, {<span class="stringliteral">&quot;center_bottom&quot;</span>, AnchorPoint::BOTTOM_CENTER},</div>
<div class="line">        {<span class="stringliteral">&quot;bottom_right&quot;</span>, AnchorPoint::BOTTOM_RIGHT}, {<span class="stringliteral">&quot;right_bottom&quot;</span>, AnchorPoint::BOTTOM_RIGHT}</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> it = map.find(s);</div>
<div class="line">    <span class="keywordflow">return</span> it != map.end() ? it-&gt;second : AnchorPoint::TOP_LEFT;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Expose <code>parseAnchor</code> to Lua via your usual binding so scripts can call <code>parseAnchor("left")</code> or pass strings directly where supported.</p>
<h1><a class="anchor" id="autotoc_md68"></a>
Migration note</h1>
<ul>
<li>Convert JSON objects into Lua modules that return tables (arrays → numeric-keyed tables; primitives map directly).</li>
<li>Example JSON <code>{ "child_anchor_x": "left" }</code> maps to Lua <code>child_anchor_x = "left"</code> in a module that returns a table.</li>
<li>For bulk conversions, a short script (Python/Node/Lua) that reads JSON and writes <code>.lua</code> modules is helpful. If runtime JSON parsing is required, add a Lua JSON library to your project — <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> does not bundle one by default. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<footer>
  <a href="#top">Back to top</a> &nbsp;|&nbsp; <a href="https://github.com/warte67/SDOM">Back to SDOM on GitHub</a>
</footer>