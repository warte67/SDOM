<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDOM - Simple SDL Document Object Model: extensible_factory</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDOM - Simple SDL Document Object Model
   </div>
   <div id="projectbrief">A lightweight, extensible Document Object Model for SDL-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_extensible__factory.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">extensible_factory</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>Initializer structs may inherit from base structs for code reuse and extensibility. </li>
</ul>
<h1><a class="anchor" id="autotoc_md37"></a>
Extensible Factory Design</h1>
<h2><a class="anchor" id="autotoc_md38"></a>
Resource Type Management</h2>
<p>In essence, the Factory serves as a simple database for all resource types in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>. By tracking each resource's type and unique name, it enables:</p><ul>
<li>Type-safe lookup and retrieval</li>
<li>Bulk queries for all resources of a given type (e.g., all Stage objects)</li>
<li>Centralized management and enumeration of resources This approach makes resource management extensible, efficient, and easy to maintain as the project grows.</li>
</ul>
<p>The Factory is responsible for creating, registering, and tracking all resource types in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>. This includes:</p><ul>
<li><b>Stage objects</b> (application windows/root display objects)</li>
<li><b>DisplayObjects</b> (Button, Label, Group, Checkbox, etc.)</li>
<li><b>Other resources</b> (bitmap images, TrueType fonts, audio files, etc.)</li>
</ul>
<p>Each resource type is registered with the Factory, allowing type-safe creation, lookup, and management. The Factory maintains internal registries for each type, enabling extensibility and centralized resource management. Stages are treated as a specific resource type, distinct from other DisplayObjects, but managed using the same registration and creation mechanisms.</p>
<p>This approach allows the Factory to:</p><ul>
<li>Track and enumerate all resources by type and unique name</li>
<li>Provide APIs for resource creation, retrieval, and destruction</li>
<li>Support future resource types with minimal changes</li>
</ul>
<p>The Core composes the Factory and uses it to create and retrieve resources, while managing the application's active Stage(s) and lifecycle.</p>
<h2><a class="anchor" id="autotoc_md39"></a>
Requirements</h2>
<ul>
<li>All DisplayObjects and ResourceObjects must be created via the Factory; direct construction is forbidden.</li>
<li>Constructors for these objects should be private, with Factory declared as a friend.</li>
<li>Factory must support both JSON/config-based and InitStructure argument construction for all object types.</li>
<li>The Factory must be extensible: new object types can be registered without hardcoded Factory methods for each type.<ul>
<li>Each resource must have a unique std::string name for identification and management.</li>
<li>Factory must support resource destruction by both unique name and resource_ptr.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
Recommended Approach</h2>
<h3><a class="anchor" id="autotoc_md41"></a>
1. Initializer Structs and JSON Configs</h3>
<ul>
<li>Each object type defines an initializer struct for manual construction, including a unique "name" field for each resource.</li>
<li>JSON configs are used for dynamic/config-based construction, and must include a unique "name" for each resource.</li>
</ul>
<h3><a class="anchor" id="autotoc_md42"></a>
2. Factory Registration</h3>
<ul>
<li>The Factory registers a creation lambda for each type, accepting either a JSON config or an initializer struct (using <code>std::any</code> or <code>std::variant</code>). Resources are registered and tracked by their unique names.</li>
<li>Example: <div class="fragment"><div class="line">registerType(<span class="stringliteral">&quot;Box&quot;</span>, [](<span class="keyword">const</span> std::any&amp; args) -&gt; std::shared_ptr&lt;IDataObject&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (args.type() == <span class="keyword">typeid</span>(BoxInit)) {</div>
<div class="line">        return std::shared_ptr&lt;Box&gt;(new Box(std::any_cast&lt;BoxInit&gt;(args)));</div>
<div class="line">    } <span class="keywordflow">else</span> if (args.type() == <span class="keyword">typeid</span>(Json)) {</div>
<div class="line">        return std::shared_ptr&lt;Box&gt;(new Box(std::any_cast&lt;Json&gt;(args)));</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_define" href="SDOM_8hpp.html#ae225ab718bd4f5e2221129f026d3d8f1">ERROR</a>(<span class="stringliteral">&quot;Box creation failed: Unknown argument type.&quot;</span>);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">});</div>
<div class="ttc" id="aSDOM_8hpp_html_ae225ab718bd4f5e2221129f026d3d8f1"><div class="ttname"><a href="SDOM_8hpp.html#ae225ab718bd4f5e2221129f026d3d8f1">ERROR</a></div><div class="ttdeci">#define ERROR(message)</div><div class="ttdoc">Throws an SDOM exception with file and line info.</div><div class="ttdef"><b>Definition</b> SDOM.hpp:375</div></div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md43"></a>
3. Factory Create Methods</h3>
<ul>
<li>The Factory exposes a generic <code>create(typeName, args)</code> method, which dispatches to the correct constructor based on argument type.</li>
<li>Convenience overloads can be provided for common patterns.</li>
</ul>
<h3><a class="anchor" id="autotoc_md44"></a>
4. Usage</h3>
<ul>
<li>Manual construction: <div class="fragment"><div class="line">InitBox boxInit;</div>
<div class="line">boxInit.name = <span class="stringliteral">&quot;myBox&quot;</span>;</div>
<div class="line">boxInit.x = 10;</div>
<div class="line">boxInit.y = 20;</div>
<div class="line">boxInit.width = 200;</div>
<div class="line">boxInit.height = 150;</div>
<div class="line">boxInit.color = SDL_Color(192,128,32,255);</div>
<div class="line"><span class="keyword">auto</span> boxObj = factory-&gt;create(<span class="stringliteral">&quot;Box&quot;</span>, boxInit);</div>
</div><!-- fragment --></li>
<li>JSON construction: <div class="fragment"><div class="line">Json boxConfig = { {<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;myBox&quot;</span>}, {<span class="stringliteral">&quot;x&quot;</span>, 10}, {<span class="stringliteral">&quot;y&quot;</span>, 20}, {<span class="stringliteral">&quot;width&quot;</span>, 200}, {<span class="stringliteral">&quot;height&quot;</span>, 150} };</div>
<div class="line"><span class="keyword">auto</span> box = factory-&gt;create(<span class="stringliteral">&quot;Box&quot;</span>, boxConfig);</div>
</div><!-- fragment --></li>
</ul>
<h2><a class="anchor" id="autotoc_md45"></a>
Benefits</h2>
<ul>
<li>Centralized, extensible object creation.</li>
<li>Consistent resource management and initialization.</li>
<li>Easy to add new object types and construction patterns.</li>
<li>No direct instantiation outside Factory.</li>
</ul>
<hr  />
<p> This document will be updated as the Factory design evolves.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
Implementation Strategy</h2>
<h3><a class="anchor" id="autotoc_md48"></a>
1. Initializer Structs</h3>
<ul>
<li>For each object/resource type, define a C++ struct (e.g., <code>InitBox</code>, <code>InitLabel</code>) containing all required fields, including a unique std::string name. These structures are based on the <code>InitDisplayObject</code> structure.</li>
<li>Example: <div class="fragment"><div class="line">  <span class="keyword">struct </span>BoxInit : <span class="keyword">public</span> InitDisplayObject</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> x, y, width, height;</div>
<div class="line">    <span class="comment">// ...other fields...</span></div>
<div class="line">  };</div>
<div class="line">- Ensure these structs can be constructed from JSON (e.g., via a helper function or constructor). Document inheritance and field usage <span class="keywordflow">for</span> contributors.</div>
<div class="line"><span class="comment">// Use a map to register creation lambdas for each type. For type safety, consider using std::variant if the set of argument types is known and limited:</span></div>
<div class="line">  <span class="keyword">using </span>CreatorFunc = std::function&lt;std::shared_ptr&lt;IDataObject&gt;(<span class="keyword">const</span> std::any&amp;)&gt;;</div>
<div class="line">  <span class="comment">// Or:</span></div>
<div class="line">  <span class="comment">// using CreatorFunc = std::function&lt;std::shared_ptr&lt;IDataObject&gt;(const std::variant&lt;BoxInit, Json&gt;&amp;)&gt;;</span></div>
<div class="line">  std::unordered_map&lt;std::string, CreatorFunc&gt; registry;</div>
<div class="line">  <span class="comment">// Register each type at startup:</span></div>
<div class="line">  registry[<span class="stringliteral">&quot;Box&quot;</span>] = [](<span class="keyword">const</span> std::any&amp; args) -&gt; std::shared_ptr&lt;IDataObject&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (args.type() == <span class="keyword">typeid</span>(BoxInit))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_shared&lt;Box&gt;(std::any_cast&lt;BoxInit&gt;(args));</div>
<div class="line">    <span class="keywordflow">if</span> (args.type() == <span class="keyword">typeid</span>(Json))</div>
<div class="line">      <span class="keywordflow">return</span> std::make_shared&lt;Box&gt;(std::any_cast&lt;Json&gt;(args));</div>
<div class="line">    <span class="comment">// ...error handling...</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">  };</div>
<div class="line">  <span class="comment">// For std::variant, use std::get_if&lt;BoxInit&gt;(&amp;args) etc.</span></div>
<div class="line">- Factory should report errors <span class="keywordflow">for</span> unknown types or invalid arguments. Decide whether to <span class="keywordflow">throw</span> exceptions, log errors, or <span class="keywordflow">return</span> <span class="keyword">nullptr</span> <span class="keywordflow">for</span> consistency.</div>
</div><!-- fragment --></li>
<li>Ensure these structs can be constructed from JSON (e.g., via a helper function or constructor).</li>
</ul>
<h3><a class="anchor" id="autotoc_md49"></a>
1a. Standardized Constructor Signatures</h3>
<ul>
<li>All DisplayObjects should have constructors with a consistent signature:<ul>
<li>One accepting the type-specific initializer struct.</li>
<li>One accepting a generic JSON/config object.</li>
</ul>
</li>
<li>Example: <div class="fragment"><div class="line"><span class="keyword">class </span>Label : <span class="keyword">public</span> IDisplayObject {</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>Factory;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    Label(<span class="keyword">const</span> InitLabel&amp; init);   <span class="comment">// Label-specific struct</span></div>
<div class="line">    Label(<span class="keyword">const</span> Json&amp; config);      <span class="comment">// Generic config</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Box : <span class="keyword">public</span> IDisplayObject {</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>Factory;</div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    Box(<span class="keyword">const</span> InitBox&amp; init);       <span class="comment">// Box-specific struct</span></div>
<div class="line">    Box(<span class="keyword">const</span> Json&amp; config);        <span class="comment">// Generic config</span></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>This ensures extensibility and consistency for Factory-based creation.</li>
</ul>
<h3><a class="anchor" id="autotoc_md50"></a>
2. Private Constructors &amp; Friend Factory</h3>
<ul>
<li>In each class, make the constructor protected/private.</li>
<li>Declare the Factory class as a friend: <div class="fragment"><div class="line"><span class="keyword">class </span>Box {</div>
<div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span>Factory;</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Box(<span class="keyword">const</span> BoxInit&amp; init);</div>
<div class="line">    Box(<span class="keyword">const</span> Json&amp; config);</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md51"></a>
3. Factory Registration System</h3>
<ul>
<li>Use a map to register creation lambdas for each type: <div class="fragment"><div class="line"><span class="keyword">using </span>CreatorFunc = std::function&lt;std::shared_ptr&lt;IDataObject&gt;(<span class="keyword">const</span> std::any&amp;)&gt;;</div>
<div class="line">std::unordered_map&lt;std::string, CreatorFunc&gt; registry;</div>
</div><!-- fragment --></li>
<li>Register each type at startup: <div class="fragment"><div class="line">registry[<span class="stringliteral">&quot;Box&quot;</span>] = [](<span class="keyword">const</span> std::any&amp; args) -&gt; std::shared_ptr&lt;IDataObject&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> (args.type() == <span class="keyword">typeid</span>(BoxInit))</div>
<div class="line">        <span class="keywordflow">return</span> std::make_shared&lt;Box&gt;(std::any_cast&lt;BoxInit&gt;(args));</div>
<div class="line">    <span class="keywordflow">if</span> (args.type() == <span class="keyword">typeid</span>(Json))</div>
<div class="line">        <span class="keywordflow">return</span> std::make_shared&lt;Box&gt;(std::any_cast&lt;Json&gt;(args));</div>
<div class="line">    <span class="comment">// ...error handling...</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md52"></a>
4. Generic Factory Create Method</h3>
<ul>
<li>Implement a method to create objects by type name and argument: <div class="fragment"><div class="line">std::shared_ptr&lt;IDataObject&gt; Factory::create(<span class="keyword">const</span> std::string&amp; type, <span class="keyword">const</span> std::any&amp; args) {</div>
<div class="line">    <span class="keyword">auto</span> it = registry.find(type);</div>
<div class="line">    <span class="keywordflow">if</span> (it != registry.end())</div>
<div class="line">        <span class="keywordflow">return</span> it-&gt;second(args);</div>
<div class="line">    <span class="comment">// ...error handling...</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Optionally, add type-safe wrappers for common types.</li>
</ul>
<h3><a class="anchor" id="autotoc_md53"></a>
5. Extensibility</h3>
<ul>
<li>New types can be registered by adding a lambda to the registry.</li>
<li>No need to modify Factory internals for new types.</li>
<li>Document the registration pattern for contributors.</li>
</ul>
<h3><a class="anchor" id="autotoc_md54"></a>
6. Error Handling &amp; Validation</h3>
<ul>
<li>Factory should report errors for unknown types, invalid arguments, or duplicate resource names.</li>
<li>Factory should also validate destruction requests by name or resource_ptr, and report errors if the resource does not exist.</li>
<li>Consider using exceptions or logging for diagnostics.</li>
</ul>
<h3><a class="anchor" id="autotoc_md55"></a>
7. Example Usage</h3>
<ul>
<li>Manual construction: <div class="fragment"><div class="line">  InitBox boxInit;</div>
<div class="line">  boxInit.name = <span class="stringliteral">&quot;myBox&quot;</span>;</div>
<div class="line">  boxInit.x = 10;</div>
<div class="line">  boxInit.y = 20;</div>
<div class="line">  boxInit.width = 200;</div>
<div class="line">  boxInit.height = 150;</div>
<div class="line">  boxInit.color = SDL_Color(192,128,32,255);</div>
<div class="line">  <span class="keyword">auto</span> boxObj = factory-&gt;create(<span class="stringliteral">&quot;Box&quot;</span>, boxInit);</div>
<div class="line">- XML support could be added in the future <span class="keywordflow">if</span> needed, but would require additional maintenance and testing. Consider abstracting config parsing so <span class="keyword">new</span> formats can be added with minimal changes.</div>
<div class="line">## Further Encapsulation: PIMPL Idiom</div>
<div class="line"> </div>
<div class="line">While the PIMPL idiom can be useful <span class="keywordflow">for</span> hiding implementation details and reducing compile-time dependencies, it adds complexity—especially in polymorphic designs like <a class="code hl_namespace" href="namespaceSDOM.html">SDOM</a>. For <span class="keyword">this</span> open source project, we prioritize maintainability and extensibility over deep encapsulation. Therefore, PIMPL is not recommended unless a compelling reason arises.</div>
<div class="ttc" id="anamespaceSDOM_html"><div class="ttname"><a href="namespaceSDOM.html">SDOM</a></div><div class="ttdoc">Contains all core classes and utilities for the SDOM library.</div></div>
</div><!-- fragment --></li>
<li>JSON construction: <div class="fragment"><div class="line">Json boxConfig = { {<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;myBox&quot;</span>}, {<span class="stringliteral">&quot;x&quot;</span>, 10}, {<span class="stringliteral">&quot;y&quot;</span>, 20}, {<span class="stringliteral">&quot;width&quot;</span>, 200}, {<span class="stringliteral">&quot;height&quot;</span>, 150} };</div>
<div class="line"><span class="keyword">auto</span> box = factory-&gt;create(<span class="stringliteral">&quot;Box&quot;</span>, boxConfig);</div>
</div><!-- fragment --></li>
</ul>
<hr  />
<p> This strategy enables centralized, extensible, and type-safe object/resource creation for <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Standardized Constructors for IDisplayObjects</h2>
<ul>
<li>Every <code>IDisplayObject</code>-based device will have two constructors:<ul>
<li>One accepting a <code>Json</code> config object for dynamic/config-based creation.</li>
<li>One accepting a type-specific initialization structure for manual construction.</li>
</ul>
</li>
<li>This approach ensures flexibility, extensibility, and consistency across all display objects.</li>
<li>Factory will use these constructors to instantiate objects based on user input or configuration.</li>
</ul>
<h2><a class="anchor" id="autotoc_md58"></a>
Configuration Format Choice</h2>
<ul>
<li>JSON is the preferred configuration format for object/resource creation.</li>
<li>JSON is widely supported and integrates easily with bindings for Java, Python, C, and Rust.</li>
<li>XML support could be added in the future if needed, but would require additional maintenance and testing.</li>
<li>Focus on making JSON robust and extensible for all use cases.</li>
</ul>
<h2><a class="anchor" id="autotoc_md59"></a>
Resource Pointer (&lt;tt&gt;resource_ptr&lt;/tt&gt;) Design</h2>
<p>To provide safe, pointer-like access to Factory-managed resources, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> introduces a custom smart pointer called <code>resource_ptr</code>. This pointer mimics the syntax and usability of a raw pointer, but internally tracks its resource via a unique name (identifier) and queries the Factory for the current pointer on each access.</p>
<h3><a class="anchor" id="autotoc_md60"></a>
How It Works</h3>
<ul>
<li>Each resource managed by the Factory is assigned a unique std::string name (identifier).</li>
<li>A <code>resource_ptr</code> stores this name and a Factory reference.</li>
<li>When the pointer is dereferenced (via <code>operator*</code>, <code>operator-&gt;</code>, or implicit conversion), it asks the Factory for the current pointer to the resource by name.</li>
<li>If the resource has been destroyed, the Factory returns <code>nullptr</code>, so the <code>resource_ptr</code> automatically becomes null and safe to use.</li>
<li>On assignment, a <code>resource_ptr</code> must be assigned to a valid Factory-managed resource (by name or pointer); otherwise, it should throw an error or log a warning.</li>
</ul>
<h3><a class="anchor" id="autotoc_md61"></a>
Example Usage</h3>
<div class="fragment"><div class="line">resource_ptr&lt;Box&gt; box = factory-&gt;create&lt;Box&gt;(...);</div>
<div class="line"><span class="keywordflow">if</span> (box) box-&gt;doSomething();</div>
<div class="line">factory-&gt;destroy(box.get()); <span class="comment">// box is automatically null after destruction</span></div>
<div class="line"><span class="keywordflow">if</span> (!box) { <span class="comment">/* safe: resource was destroyed */</span> }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Destroy by name</span></div>
<div class="line">factory-&gt;destroy(<span class="stringliteral">&quot;myBox&quot;</span>);</div>
<div class="line"><span class="comment">// Destroy by resource_ptr</span></div>
<div class="line">factory-&gt;destroy(box);</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md62"></a>
Benefits</h3>
<ul>
<li>Prevents dangling pointers—users never access deleted resources.</li>
<li>Maintains raw pointer usability and syntax for ease of use.</li>
<li>Centralizes lifetime management and pointer validity in the Factory.</li>
<li>No need for manual notification or observer lists; pointer validity is always up-to-date.</li>
<li>Unique resource names ensure reliable lookup, assignment, and destruction.</li>
</ul>
<h3><a class="anchor" id="autotoc_md63"></a>
Implementation Outline</h3>
<ul>
<li><code>resource_ptr</code> stores a resource name and a Factory reference.</li>
<li>On access, it queries the Factory for the current pointer by name.</li>
<li>If the resource is destroyed, the Factory returns <code>nullptr</code>.</li>
<li>The pointer provides all standard pointer operators for seamless integration.</li>
<li>Assignment to a resource_ptr requires validation against the Factory registry.</li>
</ul>
<h3><a class="anchor" id="autotoc_md64"></a>
Summary</h3>
<p><code>resource_ptr</code> combines the safety of smart pointers with the usability of raw pointers, making it ideal for centralized resource management in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>. It ensures that all resource references are either valid or null, with no risk of dangling pointers, and requires no extra effort from the user beyond normal pointer usage. Unique resource names and flexible destruction methods further enhance safety and usability. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<footer>
  <a href="https://github.com/warte67/SDOM">Back to SDOM on GitHub</a>
</footer>