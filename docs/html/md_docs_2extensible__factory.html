<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDOM - Simple SDL Document Object Model: Extensible Factory Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDOM - Simple SDL Document Object Model
   </div>
   <div id="projectbrief">A lightweight, extensible Document Object Model for SDL-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2extensible__factory.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Extensible Factory Design </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md142"></a></p>
<p>The Factory is where <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> creates things. Whenever the system needs a new display object (like a Button, Slider, or Label) or a new resource (like a texture or font), it asks the Factory to build it. This keeps object creation consistent and centralized, instead of scattering <span class="tt">new</span> calls throughout the codebase.</p>
<p>One important detail is that the Factory does <b>not</b> return raw pointers. Instead, it returns <b>DisplayHandles</b> and <b>AssetHandles</b>. These are lightweight, copyable references that stay valid even if the underlying object gets moved in memory or reloaded. Handles also make it possible for Lua, C++, or even other languages in the future to reference the same objects safely.</p>
<p>Objects themselves live in the Factory’s internal registry, and they stay alive as long as something is using them. When an object is removed from the visual tree, it becomes an <b>orphan</b>. Depending on the object’s configured retention policy, the Factory can keep it around, destroy it immediately, or allow it to exist for a <b>grace period</b> (useful for animated UI transitions).</p>
<p>This design lets <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> behave more like a scene graph or UI toolkit rather than a typical “immediate mode” renderer. Each element can have a lifetime, identity, name, and state that persists across frames — which is essential for building responsive, stateful interfaces.</p>
<p>For an overview of how the Factory relates to Core, Stage, EventManager, and the display tree, see: <br  />
 <span class="tt"><a class="el" href="architecture__overview_8md.html">docs/architecture_overview.md</a></span>.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md144"></a>
<b>Lua Is Optional (but First-Class)</b></h2>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> can be used in several ways:</p>
<ul>
<li><b>No Lua at all:</b> Create everything directly from C++.</li>
<li><b>Lua for configuration only:</b> Define UI layout in Lua; keep logic in C++.</li>
<li><b>Lua + C++ together:</b> Hybrid scripting and native logic.</li>
<li><b>Lua only:</b> Build applications entirely in Lua, with rendering and layout handled in optimized C++.</li>
</ul>
<p>The same handle-based architecture will also support <b>bindings for other languages</b> such as Rust and Python. The goal is to make <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> useful as both:</p>
<ul>
<li>A <b>high-performance UI engine</b>, and</li>
<li>A <b>portable scripting-friendly application framework</b>.</li>
</ul>
<hr  />
<p>So when we talk about the Factory, we are really talking about the heart of <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>: <br  />
 <b>the system that defines how objects are created, named, referenced, and eventually released.</b></p>
<p>The rest of this document explains how the Factory is structured, how lifetime rules work, and how to register new object and asset types.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md146"></a>
How a Display Object Registers Itself with the Factory</h1>
<p>In <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>, display objects are not created by calling constructors directly. <br  />
 Instead, each display object <b>registers itself</b> with the Factory, and the Factory becomes the only place that creates them.</p>
<p>This gives us three major benefits:</p>
<ol type="1">
<li><b>Consistent object creation</b> (one system controls lifetimes and references)</li>
<li><b>Lua and C++ can create the same objects using the same rules</b></li>
<li><b>Objects can be extended or added without modifying engine code</b></li>
</ol>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md148"></a>
The Core Idea</h2>
<p>Each display object type (such as <span class="tt">Box</span>, <span class="tt">Label</span>, or <span class="tt">Button</span>) provides:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Requirement  </th><th class="markdownTableHeadNone">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">An <b>InitStruct</b>  </td><td class="markdownTableBodyNone">Holds initial values such as position, size, name, etc.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">A <b>constructor that accepts the InitStruct</b>  </td><td class="markdownTableBodyNone">Allows deterministic creation via Factory.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">A <b>registration call</b>  </td><td class="markdownTableBodyNone">Tells the Factory how to build this object when requested.  </td></tr>
</table>
<p>Once registered, the type can be created using:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> box = Core::getFactory().create(<span class="stringliteral">&quot;Box&quot;</span>, initStruct);</div>
</div><!-- fragment --><p> Or fromLua: </p><div class="fragment"><div class="line">Core:createDisplayObject(&quot;Box&quot;, { name=&quot;myBox&quot;, x=50, y=50 })</div>
</div><!-- fragment --><p> No duplication. Same system, two languages.</p>
<hr  />
 <h1 class="doxsection"><a class="anchor" id="autotoc_md150"></a>
Visual Model: Where Registration Lives</h1>
<div class="fragment"><div class="line"> -norender</div>
<div class="line">flowchart LR</div>
<div class="line">  BoxClass[&quot;Box (C++ Class)&quot;] --&gt; InitStruct</div>
<div class="line">  BoxClass --&gt; RegisterFn[&quot;Registers creation function with Factory&quot;]</div>
<div class="line">  RegisterFn --&gt; Factory[&quot;Factory&quot;]</div>
<div class="line">  Factory --&gt; Creates[&quot;Creates new Box on demand&quot;]</div>
</div><!-- fragment --> <hr  />
 <h1 class="doxsection"><a class="anchor" id="autotoc_md152"></a>
A Minimal Example</h1>
<p>Let's say we are adding a new display object called <span class="tt">MyWidget</span>.</p>
<ol type="1">
<li>Define its <span class="tt">InitStruct</span>: <div class="fragment"><div class="line"><span class="keyword">struct </span>InitStruct : <span class="keyword">public</span> IDisplayObject::InitStruct {</div>
<div class="line">    <span class="keywordtype">int</span> someValue = 0;</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Implement the Class Constructor: <div class="fragment"><div class="line">MyWidget::MyWidget(<span class="keyword">const</span> InitStruct&amp; init)</div>
<div class="line">: IDisplayObject(init)</div>
<div class="line">{</div>
<div class="line">    someValue_ = init.someValue;</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Register with the Factory: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyWidget::registerWithFactory(Factory&amp; f) {</div>
<div class="line">    <span class="keywordflow">return</span> f.registerDisplayObjectType&lt;MyWidget, MyWidget::InitStruct&gt;(<span class="stringliteral">&quot;MyWidget&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --> The Factory now knows:</li>
</ol>
<ul>
<li>The <b>name</b>: <span class="tt">MyWidget</span></li>
<li>The <b>InitStruct</b> to expect</li>
<li>The <b>constructor</b> to call</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md154"></a>
What Registration Actually Looks Like Inside the Factory</h2>
<p>The Factory keeps a table: </p><div class="fragment"><div class="line">&quot;typeName&quot; → creation function</div>
</div><!-- fragment --><p> So for <span class="tt">"MyWidget"</span>, it stores something equivalent to: </p><div class="fragment"><div class="line">factory.creators_[<span class="stringliteral">&quot;MyWidget&quot;</span>] = [](<span class="keyword">const</span> InitStruct&amp; init) {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unique&lt;MyWidget&gt;(init);</div>
<div class="line">};</div>
</div><!-- fragment --> <hr  />
 <h1 class="doxsection"><a class="anchor" id="autotoc_md156"></a>
Creating a New Display Object Type</h1>
<p>When adding a new display object to <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>, there are a few moving parts — but each one has a clear purpose. <br  />
 Let’s walk through the pattern using <span class="tt">Stage</span> as an example, because <span class="tt">Stage</span> shows the full structure cleanly.</p>
<p>Every display object type must:</p>
<ol type="1">
<li>Inherit from <b>IDisplayObject</b> (or another <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> object that inherits from it)</li>
<li>Define an <b>InitStruct</b> that sets default values and custom properties</li>
<li>Provide <b>protected constructors</b> (so only the Factory can create it)</li>
<li>Provide <b>static CreateFromLua / CreateFromInitStruct callbacks</b></li>
<li>Implement lifecycle methods (<span class="tt">onInit</span>, <span class="tt">onRender</span>, etc.)</li>
<li>Register its <b>Lua bindings</b>, calling the parent first</li>
</ol>
<p>Once this is done, the object can be created from both C++ and Lua <b>without changing the Factory</b>.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md158"></a>
1. Class Declaration</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>Stage : <span class="keyword">public</span> IDisplayObject {</div>
<div class="line">    <span class="keyword">using </span>SUPER = IDisplayObject;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* TypeName = <span class="stringliteral">&quot;Stage&quot;</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">struct </span>InitStruct : <span class="keyword">public</span> IDisplayObject::InitStruct {</div>
<div class="line">        InitStruct() {</div>
<div class="line">            name = TypeName;</div>
<div class="line">            type = TypeName;</div>
<div class="line">            color = {0, 0, 0, 255};</div>
<div class="line">            <span class="comment">// example custom property:</span></div>
<div class="line">            <span class="comment">// bool enableSomething = true;</span></div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    Stage(<span class="keyword">const</span> InitStruct&amp; init);</div>
<div class="line">    Stage(<span class="keyword">const</span> sol::table&amp; config);</div>
<div class="line">    Stage(<span class="keyword">const</span> sol::table&amp; config, <span class="keyword">const</span> InitStruct&amp; defaults);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> std::unique_ptr&lt;IDisplayObject&gt; CreateFromLua(<span class="keyword">const</span> sol::table&amp; config) {</div>
<div class="line">        <span class="keywordflow">return</span> std::unique_ptr&lt;IDisplayObject&gt;(<span class="keyword">new</span> Stage(config));</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">static</span> std::unique_ptr&lt;IDisplayObject&gt; CreateFromInitStruct(<span class="keyword">const</span> IDisplayObject::InitStruct&amp; baseInit) {</div>
<div class="line">        <span class="keywordflow">return</span> std::unique_ptr&lt;IDisplayObject&gt;(<span class="keyword">new</span> Stage(<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Stage::InitStruct&amp;<span class="keyword">&gt;</span>(baseInit)));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> ~Stage() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Object lifecycle and rendering</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> onInit() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onQuit() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onUpdate(<span class="keywordtype">float</span> dt) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onEvent(<span class="keyword">const</span> Event&amp; event) <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> onRender() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">bool</span> onUnitTest() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> _registerLuaBindings(<span class="keyword">const</span> std::string&amp; typeName, sol::state_view lua);</div>
<div class="line">    sol::usertype&lt;Stage&gt; objHandleType_;</div>
<div class="line">};</div>
</div><!-- fragment --> <hr  />
 <h2 class="doxsection"><a class="anchor" id="autotoc_md160"></a>
1. Why These Pieces Exist</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Code Element  </th><th class="markdownTableHeadNone">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">SUPER = IDisplayObject</span>  </td><td class="markdownTableBodyNone">Gives easy access to the base class (we’ll use this soon).  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">static constexpr const char* TypeName</span>  </td><td class="markdownTableBodyNone">The global identity of the object type. Used by C++, Lua, Factory, debugging, etc.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">InitStruct</span>  </td><td class="markdownTableBodyNone">Defines default values and new custom properties your object adds.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Protected Constructors</span>  </td><td class="markdownTableBodyNone">Ensures objects can <b>only be created by the Factory</b>, never by accident.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">CreateFromInitStruct</span>  </td><td class="markdownTableBodyNone">These are the hooks the Factory calls to actually construct your object.  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">Lifecycle overrides</span>  </td><td class="markdownTableBodyNone">Allow your object to draw, update, handle input, etc.  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">_registerLuaBindings()</span>  </td><td class="markdownTableBodyNone">Connects your object to Lua, tools, and scripting.  </td></tr>
</table>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md162"></a>
2. Lua Binding (Important Detail!)</h2>
<p>Here is the <span class="tt">critical rule</span> when registering Lua bindings: </p><blockquote class="doxtable">
<p>Always call the base class binding function first. This ensures your object inherits all the Lua features of its parent. </p>
</blockquote>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> Stage::_registerLuaBindings(<span class="keyword">const</span> std::string&amp; typeName, sol::state_view lua) {</div>
<div class="line">    <span class="comment">// Inherit all Lua bindings from IDisplayObject first</span></div>
<div class="line">    SUPER::_registerLuaBindings(typeName, lua);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Create or reuse usertype</span></div>
<div class="line">    <span class="keywordflow">if</span> (!lua[typeName].valid()) {</div>
<div class="line">        objHandleType_ = lua.new_usertype&lt;Stage&gt;(</div>
<div class="line">            typeName,</div>
<div class="line">            sol::no_constructor,</div>
<div class="line">            sol::base_classes, sol::bases&lt;IDisplayObject&gt;()</div>
<div class="line">        );</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        objHandleType_ = lua[typeName];</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    sol::table stageTable = lua[typeName];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Utility to avoid overriding base-class bindings</span></div>
<div class="line">    <span class="keyword">auto</span> set_if_absent = [](sol::table&amp; tbl, <span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">auto</span>&amp;&amp; fn) {</div>
<div class="line">        <span class="keywordflow">if</span> (!tbl.raw_get_or(name, sol::lua_nil).valid()) {</div>
<div class="line">            tbl.set_function(name, std::forward&lt;<span class="keyword">decltype</span>(fn)&gt;(fn));</div>
<div class="line">        }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Add Stage-specific Lua methods here</span></div>
<div class="line">    set_if_absent(stageTable, <span class="stringliteral">&quot;getMouseX&quot;</span>, &amp;Stage::getMouseX_lua);</div>
<div class="line">    set_if_absent(stageTable, <span class="stringliteral">&quot;getMouseY&quot;</span>, &amp;Stage::getMouseY_lua);</div>
<div class="line">    set_if_absent(stageTable, <span class="stringliteral">&quot;setMouseX&quot;</span>, &amp;Stage::setMouseX_lua);</div>
<div class="line">    set_if_absent(stageTable, <span class="stringliteral">&quot;setMouseY&quot;</span>, &amp;Stage::setMouseY_lua);</div>
<div class="line">}</div>
</div><!-- fragment --><p> So the new type gets:</p><ul>
<li>All base IDisplayObject Lua features</li>
<li>Plus your custom bindings</li>
<li>Without overwriting or duplicating anything</li>
</ul>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md164"></a>
3. Summary Checklist (Copy This When Creating New Objects)</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Step  </th><th class="markdownTableHeadNone">Done?  </th><th class="markdownTableHeadNone">Notes  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Inherit from <span class="tt">IDisplayObject</span>  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone">Or a subclass  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Define <span class="tt">static TypeName</span>  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone">Global identity  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Create an <span class="tt">InitStruct</span>  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone">With defaults and custom properties  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Make constructors protected  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone">Factory-only creation  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Add <span class="tt">CreateFromInitStruct</span> and <span class="tt">  CreateFromLua</span>  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone">Used by Factory  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Override lifecycle methods  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone"><span class="tt">onInit</span>, <span class="tt">onRender</span>, ... UI logic happens here  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Implement <span class="tt">_registerLuaBindings()</span>  </td><td class="markdownTableBodyNone">☐  </td><td class="markdownTableBodyNone">Call <span class="tt">SUPER::_registerLuaBindings</span> first  </td></tr>
</table>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md166"></a>
Object Lifetimes, Parents, and Orphans</h1>
<p><em>(aka: “Why Your UI Elements Don’t Turn Into Zombies”)</em></p>
<p>Every display object in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> lives somewhere in the <b>display tree</b>. <br  />
 If an object has a parent, it's part of the active UI. <br  />
 If it <em>loses</em> its parent… well… now we need to talk about <b>orphans</b>.</p>
<p>Think of the display tree like a family photo: </p><div class="fragment"><div class="line">Stage (root)</div>
<div class="line">│</div>
<div class="line">├── Box (&quot;blueishBox&quot;)</div>
<div class="line">│ └── Label (&quot;blueishBoxLabel&quot;)</div>
<div class="line">│</div>
<div class="line">└── Button (&quot;main_stage_button&quot;)</div>
<div class="line">    └── Label (&quot;buttonLabel&quot;)</div>
</div><!-- fragment --><p>As long as everyone has a parent, life is good. <br  />
 But if you remove a child: </p><div class="fragment"><div class="line">stage:removeChild(&quot;blueishBox&quot;)</div>
</div><!-- fragment --><p> Now <b>blueishBox</b> and everything inside it becomes an orphan.</p>
<hr  />
 <h1 class="doxsection"><a class="anchor" id="autotoc_md168"></a>
Why Orphans Exist (And Why They’re Actually Useful)</h1>
<p>In many UI frameworks, removing an element means destroying it instantly.</p>
<p>But <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> takes a different approach: </p><blockquote class="doxtable">
<p>Removing something from the UI does not automatically destroy it. </p>
</blockquote>
<p>This is great because:</p><ul>
<li>✅ You can bring it back later</li>
<li>✅ You can animate it fading away</li>
<li>✅ You can inspect it for debugging</li>
<li>✅ Lua references won’t suddenly explode</li>
</ul>
<p>Instead, every display object has an: </p><div class="fragment"><div class="line">RetentionPolicy retentionPolicy_;</div>
</div><!-- fragment --><p> Which decides <b>what to do when the object is no longer part of the scene graph.</b></p>
<p>Here are the policies: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Policy  </th><th class="markdownTableHeadNone">Meaning  </th><th class="markdownTableHeadNone">Use Case  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">AutoDestroy</span>  </td><td class="markdownTableBodyNone">Destroy immediately  </td><td class="markdownTableBodyNone">Temporary UI elements you don’t reuse  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">GracePeriod</span>  </td><td class="markdownTableBodyNone">Wait (e.g., 200-400ms), then destroy  </td><td class="markdownTableBodyNone">Fade-out animations or transition effects  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><span class="tt">RetainUntilManual</span>  </td><td class="markdownTableBodyNone">Keep forever until manually destroyed  </td><td class="markdownTableBodyNone">Inventory windows, cached panels, lazily reused elements  </td></tr>
</table>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md170"></a>
Visualizing the Orphan Lifecycle</h2>
<div class="fragment"><div class="line">Remove From Parent         Time Passes          collectGarbage()</div>
<div class="line">        │                         │                     │</div>
<div class="line">        ▼                         ▼                     ▼</div>
<div class="line">   (object is orphaned) ──→  (policy considered) ──→ (destroy or retain)</div>
<div class="line">        │                         │                     │</div>
<div class="line">        └─────────────────────────┴─────────────────────┘</div>
</div><!-- fragment --><p> And yes — <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> prevents zombie references: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Scenario  </th><th class="markdownTableHeadNone">Result  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">You still hold a DisplayHandle to the orphan  </td><td class="markdownTableBodyNone">✅ It stays valid  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">The object gets destroyed later  </td><td class="markdownTableBodyNone">⚠️ Handle becomes <em>invalid</em>, but safe (it just returns <span class="tt">nullptr</span>)  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">You accidentally keep handles forever  </td><td class="markdownTableBodyNone">✅ <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> will not leak — you are just hoarding ghosts 👻  </td></tr>
</table>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md172"></a>
The Cleanup Loop (Automatically Happens Each Frame)</h2>
<p>Inside the main loop, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> does: </p><div class="fragment"><div class="line">factory-&gt;detachOrphans();         <span class="comment">// Remove objects from tree but keep alive</span></div>
<div class="line">factory-&gt;attachFutureChildren();  <span class="comment">// Handle queued child additions</span></div>
<div class="line">factory-&gt;collectGarbage();        <span class="comment">// Apply retention policies &amp; destroy if needed</span></div>
</div><!-- fragment --><p> You don’t call this. You don’t need to remember it. It just happens. Like sunrise. Or taxes. Or reruns of The Munsters.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md174"></a>
Example: Fade-Out Animation Using GracePeriod</h2>
<div class="fragment"><div class="line">local panel = Core:getDisplayObject(&quot;settingsPanel&quot;)</div>
<div class="line"> </div>
<div class="line">panel:setOrphanRetentionPolicy(&quot;GracePeriod&quot;)</div>
<div class="line">panel:setOrphanGrace(300) -- keep alive for 300ms</div>
<div class="line"> </div>
<div class="line">-- Play exit animation</div>
<div class="line">panel:animateFadeOut(0.3)</div>
<div class="line"> </div>
<div class="line">-- Remove from UI</div>
<div class="line">stage:removeChild(panel)</div>
<div class="line"> </div>
<div class="line">-- Panel will auto-destroy after animation finishes.</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md175"></a>
Example: UI Reuse With RetainUntilManual</h2>
<div class="fragment"><div class="line">-- Create once</div>
<div class="line">local inventory = Core:createDisplayObject(&quot;Frame&quot;, { name=&quot;inventory&quot;, width=300, height=200 })</div>
<div class="line">inventory:setOrphanRetentionPolicy(&quot;RetainUntilManual&quot;)</div>
<div class="line"> </div>
<div class="line">stage:addChild(inventory)  -- show it</div>
<div class="line">stage:removeChild(inventory) -- hide it (object still exists)</div>
<div class="line">stage:addChild(inventory) -- show it again, instantly, no re-alloc!</div>
</div><!-- fragment --><hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md177"></a>
Key Takeaways</h2>
<ul>
<li>Removing something from the UI does not necessarily destroy it.</li>
<li>Every display object has a retention policy that determines its lifetime.</li>
<li>collectGarbage() applies policies automatically each frame.</li>
<li>Handles always remain safe — never dangling pointers. In short: This is one of the core reasons the system feels stable, predictable, and easy to build <em>real interfaces</em> with.</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md179"></a>
Adding Custom Properties to Your Display Object</h1>
<p><em>(or: "Yes, you can absolutely give your Button a hitpoint system")</em></p>
<p>When you create a new display object type, the <span class="tt">InitStruct</span> is where you define its <b>default values</b> — including your own custom fields.</p>
<p>Let’s say we’re creating a new UI element: It’s like a <span class="tt">Frame</span>, except it can be expanded or collapsed.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md180"></a>
1. Add the Property to the InitStruct</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>InitStruct : <span class="keyword">public</span> IDisplayObject::InitStruct</div>
<div class="line">{</div>
<div class="line">    InitStruct() : IDisplayObject::InitStruct()</div>
<div class="line">    {</div>
<div class="line">        name = TypeName;</div>
<div class="line">        type = TypeName;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">bool</span> isCollapsed = <span class="keyword">false</span>;   <span class="comment">// 👈 Our custom property</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> Now our object has state — something meaningful that controls behavior.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md182"></a>
2. Store the Property in the Class</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>TogglePanel : <span class="keyword">public</span> IDisplayObject</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>SUPER = IDisplayObject;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> isCollapsed_ = <span class="keyword">false</span>;  <span class="comment">// internal storage</span></div>
</div><!-- fragment --> <hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md184"></a>
3. Copy it In from Constructors</h2>
<div class="fragment"><div class="line">TogglePanel(<span class="keyword">const</span> InitStruct&amp; init) : SUPER(init)</div>
<div class="line">{</div>
<div class="line">    isCollapsed_ = init.isCollapsed;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TogglePanel(<span class="keyword">const</span> sol::table&amp; config) : SUPER(config)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (config[<span class="stringliteral">&quot;isCollapsed&quot;</span>].valid())</div>
<div class="line">        isCollapsed_ = config[<span class="stringliteral">&quot;isCollapsed&quot;</span>].get&lt;bool&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p> Now both C++ creation and Lua creation can initialize this field.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md186"></a>
4. Add Getters / Setters</h2>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> isCollapsed()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> isCollapsed_; }</div>
<div class="line">    <span class="keywordtype">void</span> setCollapsed(<span class="keywordtype">bool</span> c) { </div>
<div class="line">        <span class="keywordflow">if</span> (isCollapsed_ != c) {</div>
<div class="line">            isCollapsed_ = c;</div>
<div class="line">            setDirty();   <span class="comment">// mark for redraw / relayout</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
</div><!-- fragment --><p> Notice the call to <span class="tt">setDirty()</span> — this ensures the UI will visually update next frame.</p>
<hr  />
 <h2 class="doxsection"><a class="anchor" id="autotoc_md188"></a>
5. Expose It to Lua (Inside <span class="tt">_registerLuaBindings()</span>)</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TogglePanel::_registerLuaBindings(<span class="keyword">const</span> std::string&amp; typeName, sol::state_view lua)</div>
<div class="line">{</div>
<div class="line">    SUPER::_registerLuaBindings(typeName, lua);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> panel = lua[typeName];</div>
<div class="line"> </div>
<div class="line">    panel.set_function(<span class="stringliteral">&quot;isCollapsed&quot;</span>, &amp;TogglePanel::isCollapsed);</div>
<div class="line">    panel.set_function(<span class="stringliteral">&quot;setCollapsed&quot;</span>, &amp;TogglePanel::setCollapsed);</div>
<div class="line">}</div>
</div><!-- fragment --><p> And now Lua can happily do: </p><div class="fragment"><div class="line">panel:setCollapsed(true)</div>
</div><!-- fragment --><p> Or read it: </p><div class="fragment"><div class="line">if panel:isCollapsed() then</div>
<div class="line">    print(&quot;Panel is closed.&quot;)</div>
<div class="line">end</div>
</div><!-- fragment --> <hr  />
 <h2 class="doxsection"><a class="anchor" id="autotoc_md189"></a>
Visualizing the Flow</h2>
<div class="fragment"><div class="line">Lua or C++ → InitStruct → Constructors → Internal State → Lua Bindings</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    setCollapsed()</div>
<div class="line">           │</div>
<div class="line">           ▼</div>
<div class="line">     mark object dirty</div>
<div class="line">           │</div>
<div class="line">           ▼</div>
<div class="line">next frame → Label redraw, layout update, rendering correct</div>
</div><!-- fragment --><p> This makes UI state reactive — updates propagate naturally through the render pipeline.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md191"></a>
Optional: Reflecting Properties Back Into Lua Tables</h2>
<p>If your object supports saving/loading UI layouts, you can override: </p><div class="fragment"><div class="line">sol::table toLuaConfig(sol::state_view lua) <span class="keyword">const override</span>;</div>
</div><!-- fragment --><p> Which lets you serialize back into lua: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> cfg = panel-&gt;toLuaConfig(L);</div>
<div class="line">-- cfg now contains { name=<span class="stringliteral">&quot;foo&quot;</span>, type=<span class="stringliteral">&quot;TogglePanel&quot;</span>, isCollapsed=<span class="keyword">true</span>, x=.., y=.. }</div>
</div><!-- fragment --><p> (We’ll go deeper into serialization support later — this is enough to get started.)</p>
<hr  />
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Concept  </th><th class="markdownTableHeadNone">Why It Matters  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Custom fields belong in the <span class="tt">InitStruct</span>  </td><td class="markdownTableBodyNone">So defaults are easy and consistent  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Constructors must copy config → state  </td><td class="markdownTableBodyNone">Otherwise properties won’t actually <em>apply</em>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Always call <span class="tt">setDirty()</span> when appearance changes  </td><td class="markdownTableBodyNone">Ensures rendering refreshes correctly  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><span class="tt">_registerLuaBindings()</span> connects Lua to your new API  </td><td class="markdownTableBodyNone">Makes the object scriptable AND testable  </td></tr>
</table>
<hr  />
<p>If you follow this simple pattern, you can create:</p><ul>
<li>Windows that slide in/out</li>
<li>Dynamic meters and bars</li>
<li>Health bars on buttons (why not?)</li>
<li>Animated menus</li>
<li>RTT debug panels</li>
<li>Even game HUD elements</li>
</ul>
<p>All while keeping the behavior clean, deterministic, and easy to reason about.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md194"></a>
Where to Put Your Logic: Rendering, Layout, Updates, and Input</h1>
<p>Every display object in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> participates in the <b>frame loop</b>. <br  />
 If your custom object is going to <em>move, animate, respond to input, draw things,</em> or change layout, you’ll do that in one of the core virtual methods it inherits from <span class="tt">IDisplayObject</span>.</p>
<p>Here’s the lifecycle:</p>
<div class="fragment"><div class="line">onInit()   → Runs once when created</div>
<div class="line">onUpdate() → Runs every frame (logic, animation, timers)</div>
<div class="line">onEvent()  → Runs whenever input or UI events occur</div>
<div class="line">onRender() → Draws the object (background, content, borders, etc.)</div>
<div class="line">onQuit()   → Runs when the program shuts down or object is destroyed</div>
</div><!-- fragment --><p>Let’s break down what each is <b>for</b>, and what it is <b>not</b> for.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md196"></a>
<span class="tt">onInit()</span>: Setup, Don’t Draw Yet</h2>
<p>This is called <em>right after</em> the object is registered in the Factory.</p>
<p>Use it for:</p><ul>
<li>Creating child objects</li>
<li>Computing initial layout</li>
<li>Loading secondary assets</li>
<li>Connecting to event listeners</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> TogglePanel::onInit()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Example: Create a label inside the panel</span></div>
<div class="line">    <span class="keyword">auto</span> label = Core::getFactory().create(<span class="stringliteral">&quot;Label&quot;</span>, { .name=<span class="stringliteral">&quot;panelText&quot;</span>, .text=<span class="stringliteral">&quot;Hello!&quot;</span> });</div>
<div class="line">    addChild(label);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Don’t draw here — nothing is on screen yet.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md198"></a>
<span class="tt">onUpdate(float dt)</span>: Animation / State Changes</h2>
<p>Called every frame before rendering. <br  />
 Great for timers, animations, and logic.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TogglePanel::onUpdate(<span class="keywordtype">float</span> dt)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (isCollapsed_) {</div>
<div class="line">        height_ = std::max(height_ - <span class="keywordtype">int</span>(200 * dt), 20);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        height_ = std::min(height_ + <span class="keywordtype">int</span>(200 * dt), 200);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Rule of thumb:</b> <br  />
 If it changes <em>state</em>, call <span class="tt">setDirty()</span>.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md200"></a>
<span class="tt">onEvent(const Event&amp;)</span>: Input &amp; UI Interaction</h2>
<p>You don’t need to poll SDL manually — the event system handles that. <br  />
 You just react to semantic events.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TogglePanel::onEvent(<span class="keyword">const</span> Event&amp; ev)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (ev.type == EventType::MouseDown &amp;&amp; ev.target == getHandle()) {</div>
<div class="line">        setCollapsed(!isCollapsed_);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> handles capture → target → bubble automatically.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md202"></a>
<span class="tt">onRender()</span>: <em>Actually draw something</em></h2>
<p>This is where you:</p>
<ul>
<li>Draw backgrounds</li>
<li>Draw outlines or borders</li>
<li>Draw sprites/textures</li>
<li>Render any immediate-mode visuals</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TogglePanel::onRender()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> r = Core::getRenderer();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Fill background</span></div>
<div class="line">    SDL_Color c = isCollapsed_ ? SDL_Color{50, 50, 50, 255}</div>
<div class="line">                               : SDL_Color{90, 90, 90, 255};</div>
<div class="line">    SDL_SetRenderDrawColor(r, c.r, c.g, c.b, c.a);</div>
<div class="line"> </div>
<div class="line">    SDL_FRect rect = { getX(), getY(), getWidth(), getHeight() };</div>
<div class="line">    SDL_RenderFillRect(r, &amp;rect);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Borders (optional)</span></div>
<div class="line">    drawBorder();</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Important:</b> <br  />
 Don’t draw children here — <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> handles that automatically.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md204"></a>
<span class="tt">onQuit()</span>: Clean Up <em>If Needed</em></h2>
<p>Most objects don’t need custom cleanup because:</p><ul>
<li>Lifetime is managed by the Factory</li>
<li>Rendered textures are owned by the renderer or Label’s own cache</li>
<li>Children are cleaned when removed or orphan-collected</li>
</ul>
<p>Only override if needed:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> TogglePanel::onQuit()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Most objects will not need this.</span></div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md206"></a>
Putting It All Together</h1>
<div class="fragment"><div class="line">              +----------------+</div>
<div class="line">              |  constructor   |</div>
<div class="line">              +--------+-------+</div>
<div class="line">                       |</div>
<div class="line">                       v</div>
<div class="line">               +-------+------+</div>
<div class="line">               |   onInit()   |  &lt;-- setup &amp; wiring</div>
<div class="line">               +-------+------+</div>
<div class="line">                       |</div>
<div class="line">        Every frame    |      Input events</div>
<div class="line">     +------------------+-------------+</div>
<div class="line">     |                                |</div>
<div class="line">     v                                v</div>
<div class="line">+----+-----+                     +----+------+</div>
<div class="line">| onUpdate |                     | onEvent   | &lt;-- logic &amp; state change</div>
<div class="line">+----+-----+                     +----+------+</div>
<div class="line">     |                                |</div>
<div class="line">     +---------------+----------------+</div>
<div class="line">                     |</div>
<div class="line">                     v</div>
<div class="line">               +-----+------+</div>
<div class="line">               |  onRender  |  &lt;-- draw to screen</div>
<div class="line">               +------------+</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md208"></a>
Practical Tip — When in Doubt:</h1>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">You want to…  </th><th class="markdownTableHeadNone">Use…  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Create or configure sub-objects  </td><td class="markdownTableBodyNone"><span class="tt">onInit()</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Animate something over time  </td><td class="markdownTableBodyNone"><span class="tt">onUpdate()</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Respond to user input  </td><td class="markdownTableBodyNone"><span class="tt">onEvent()</span>  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Draw visuals  </td><td class="markdownTableBodyNone"><span class="tt">onRender()</span>  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Release external resources  </td><td class="markdownTableBodyNone"><span class="tt">onQuit()</span>  </td></tr>
</table>
<hr  />
 </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<footer>
  <a href="#top">Back to top</a> &nbsp;|&nbsp; <a href="https://github.com/warte67/SDOM">Back to SDOM on GitHub</a>
</footer>
