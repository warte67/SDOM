<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SDOM - Simple SDL Document Object Model: Core Framework Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SDOM - Simple SDL Document Object Model
   </div>
   <div id="projectbrief">A lightweight, extensible Document Object Model for SDL-based applications.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md_docs_2core__framework.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Core Framework Design </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md14"></a></p>
<p>See also: overall architecture diagram in <a class="el" href="architecture__overview_8md.html">docs/architecture_overview.md</a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md15"></a>
Overview</h1>
<p>Core is the runtime orchestrator of <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>. It bootstraps the SDL video subsystem (window, renderer, main texture), owns the main loop, and provides a single place to configure timing, presentation, and error handling. As a singleton, Core gives the application one stable entry point: you configure it up front, call run(), and it drives initialization, updates, event polling/dispatch, rendering, and shutdown in a predictable order.</p>
<p>Core coordinates the major subsystems that make up <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a>. It ensures types are registered with the Factory and creates the root Stage (the head of the display tree). Each frame, Core asks the EventManager to propagate input through capture → target → bubble phases across the display hierarchy, then invokes Stage::onUpdate(dt) and Stage::onRender(). By centralizing ownership of the window/renderer and delegating domain work to Stage, Factory, and EventManager, Core keeps responsibilities clean while maintaining tight control of the application lifecycle.</p>
<p>Core is designed for extensibility as well as simplicity. Applications can plug into lifecycle callbacks (init, update, event, render, quit), register hooks from other languages, and manage “scenes” by swapping the active Stage (changing the root of the DOM tree) without reinitializing the engine. Window resizing, presentation policy, and shutdown are handled centrally, while the Factory and typed handles decouple object creation and references from the objects’ lifetimes. The result is a compact core with clear extension points and a reliable runtime model. For guidance on scripting and configuration (Lua-first via sol2), see <a class="el" href="md_docs_2scripting__and__configuration.html">Scripting and Configuration</a> for recommended bindings, lifecycle hooks, and examples.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md16"></a>
Core Responsibilities</h1>
<ul>
<li>Singleton pattern for global access and lifecycle management</li>
<li>Main SDL loop management</li>
<li>Error logging and trapping</li>
<li>Composition and management of:<ul>
<li>Factory (object/resource creation)</li>
<li>EventManager (event dispatch and handling)</li>
<li>Stage (the root display object)</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md17"></a>
Core Initialization Sequence &amp; Pre-Initialization Configuration</h1>
<p>To ensure proper setup, <span class="tt">onInit()</span> should be called <b>after</b> the SDL Video Subsystem (window, renderer, texture) has been created and initialized. This requires that all necessary configuration parameters are provided to Core <b>before</b> initialization begins.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md18"></a>
Required Pre-Initialization Parameters:</h2>
<ul>
<li><b>Core (Pixel) Resolution:</b> The logical pixel dimensions for rendering.</li>
<li><b>Initial Window Size:</b> The starting size of the SDL window.</li>
<li><b>Rendering Flags:</b> SDL renderer creation flags (e.g., hardware acceleration, vsync).</li>
<li><b>Presentation Flags:</b> SDL window flags (e.g., resizable, fullscreen).</li>
<li><b>Color Format:</b> Desired pixel format for rendering and textures.</li>
<li><b>Other SDL/graphics options:</b> As needed for your application.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md19"></a>
Initialization Flow:</h2>
<ol type="1">
<li><b>Configure Core:</b> <br  />
 Pass all required parameters to Core via a configuration struct or initialization method.</li>
<li><b>Create SDL Video Subsystem:</b> <br  />
 Core creates the SDL window, renderer, and main display texture using the provided settings.</li>
<li><b>Call onInit():</b> <br  />
 Once the video subsystem is ready, Core invokes <span class="tt">onInit()</span> to allow application-specific initialization (e.g., loading assets, setting up stages).</li>
<li><b>Enter Main Loop:</b> <br  />
 Core proceeds with the main SDL loop, event handling, and rendering.</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Example Configuration API:</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>CoreConfig {</div>
<div class="line">    <span class="keywordtype">float</span> windowWidth;</div>
<div class="line">    <span class="keywordtype">float</span> windowHeight;</div>
<div class="line">    <span class="keywordtype">float</span> pixelWidth;   <span class="comment">// Virtual width of a single pixel (for logical scaling; can be fractional/non-square)</span></div>
<div class="line">    <span class="keywordtype">float</span> pixelHeight;  <span class="comment">// Virtual height of a single pixel (for logical scaling; can be fractional/non-square)</span></div>
<div class="line">    <span class="keywordtype">bool</span> preserveAspectRatio = <span class="keyword">true</span>;    <span class="comment">// Preserve original aspect ratio when resizing window</span></div>
<div class="line">    <span class="keywordtype">bool</span> allowTextureResize = <span class="keyword">true</span>;     <span class="comment">// Allow texture resolution to change when resizing window</span></div>
<div class="line">    SDL_RendererLogicalPresentation rendererFlags;</div>
<div class="line">    SDL_WindowFlags windowFlags;</div>
<div class="line">    SDL_PixelFormat colorFormat;</div>
<div class="line">    <span class="comment">// ... other options ...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">Core&amp; core = getCore();</div>
<div class="line">core.configure(CoreConfig{<span class="comment">/* ... */</span>});</div>
<div class="line">core.run(); <span class="comment">// Internally calls onInit() after SDL setup</span></div>
</div><!-- fragment --><p><b>Note:</b> <br  />
 All pre-initialization information must be set before calling <span class="tt">run()</span> or starting the main loop. This ensures that the video subsystem is correctly configured and available for all subsequent operations.</p>
<hr  />
<h2 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Alternative Initialization: Lua Configuration</h2>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> uses Lua (via sol2) as the canonical configuration and scripting mechanism. Instead of JSON configuration, prefer Lua modules that return tables. Below is a minimal example showing a Lua configuration module and how C++ can load it with Sol2.</p>
<p>Example Lua module <span class="tt">config/core_config.lua</span>:</p>
<div class="fragment"><div class="line">return {</div>
<div class="line">  core = {</div>
<div class="line">    windowWidth = 1280,</div>
<div class="line">    windowHeight = 720,</div>
<div class="line">    pixelWidth = 2.0,</div>
<div class="line">    pixelHeight = 2.0,</div>
<div class="line">    allowTextureResize = false,</div>
<div class="line">    preserveAspectRatio = true,</div>
<div class="line">    rendererFlags = &quot;SDL_LOGICAL_PRESENTATION_LETTERBOX&quot;,</div>
<div class="line">    windowFlags = &quot;SDL_WINDOW_FULLSCREEN | SDL_WINDOW_RESIZABLE&quot;,</div>
<div class="line">    colorFormat = &quot;SDL_PIXELFORMAT_RGBA8888&quot;,</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Example C++ usage (Sol2):</p>
<div class="fragment"><div class="line"><span class="comment">// Load configuration from Lua and hand it to Core</span></div>
<div class="line">sol::state&amp; lua = core.getLua();                      <span class="comment">// obtain the Core-managed Lua state</span></div>
<div class="line">sol::table cfg = lua.require&lt;sol::table&gt;(<span class="stringliteral">&quot;config.core_config&quot;</span>);</div>
<div class="line">core.configureFromLuaTable(cfg);                      <span class="comment">// or core.configure(cfg);</span></div>
<div class="line">core.run();</div>
</div><!-- fragment --><p>Migration note</p><ul>
<li>Convert JSON objects into Lua modules that return tables (arrays map to numeric-keyed tables; primitives map directly).</li>
<li>For bulk conversions, a small script (Python/Node/Lua) that reads JSON and emits equivalent Lua table source is useful.</li>
<li>If you must parse JSON at runtime instead of converting files, add a Lua JSON library to your application — <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> does not bundle JSON parsing by default.</li>
</ul>
<hr  />
<p>Let me know if you want this added to a specific section, or if you’d like to expand on configuration struct details or error handling for initialization!</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Primary Callbacks</h1>
<p>The Core exposes the following virtual callback methods, which are invoked during the application lifecycle:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onQuit () <span class="keyword">override</span>;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onUpdate (<span class="keywordtype">float</span> fElapsedTime) = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onEvent (<span class="keyword">const</span> Event &amp;event) = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span>  onRender () = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span>  onUnitTest ();</div>
</div><!-- fragment --><ul>
<li><span class="tt">onInit()</span>: Called during initialization.</li>
<li><span class="tt">onQuit()</span>: Called during shutdown/cleanup.</li>
<li><span class="tt">onUpdate(float fElapsedTime)</span>: Called every frame to update logic.</li>
<li><span class="tt">onEvent(const Event &amp;event)</span>: Called for each incoming event.</li>
<li><span class="tt">onRender()</span>: Called every frame to render the stage.</li>
<li><span class="tt">onUnitTest()</span>: Called to run unit tests.</li>
</ul>
<p>Each callback is designed to interact directly with the single Stage object, which represents the root of the display hierarchy.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Hook &amp; Callback Registration</h1>
<p>To support extensibility across multiple languages (C++, Python, Rust, etc.), the Core framework provides a hook/callback registration system for all primary lifecycle and event methods. Instead of requiring inheritance, users can register function pointers, std::function, or language bindings for each event:</p>
<ul>
<li>Initialization: <span class="tt">registerOnInit(std::function&lt;bool()&gt;)</span></li>
<li>Quit: <span class="tt">registerOnQuit(std::function&lt;void()&gt;)</span></li>
<li>Update: <span class="tt">registerOnUpdate(std::function&lt;void(float)&gt;)</span></li>
<li>Event: <span class="tt">registerOnEvent(std::function&lt;void(const Event&amp;)&gt;)</span></li>
<li>Render: <span class="tt">registerOnRender(std::function&lt;void()&gt;)</span></li>
<li>Unit Test: <span class="tt">registerOnUnitTest(std::function&lt;bool()&gt;)</span></li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Example (C++)</h2>
<div class="fragment"><div class="line">Core core;</div>
<div class="line">core.registerOnInit([]() { <span class="comment">/* ... */</span> <span class="keywordflow">return</span> <span class="keyword">true</span>; });</div>
<div class="line">core.registerOnQuit([]() { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnUpdate([](<span class="keywordtype">float</span> dt) { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnEvent([](<span class="keyword">const</span> Event&amp; e) { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnRender([]() { <span class="comment">/* ... */</span> });</div>
<div class="line">core.registerOnUnitTest([]() { <span class="comment">/* ... */</span> <span class="keywordflow">return</span> <span class="keyword">true</span>; });</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Example (Python/Rust)</h2>
<p>Bindings can expose similar registration functions, allowing users to set hooks in their language of choice.</p><ul>
<li>Core stores each hook as a function object.</li>
<li>At each lifecycle stage, Core checks for a registered hook and invokes it if present.</li>
<li>Inheritance remains an option for C++ users, but is not required for other languages.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md28"></a>
Global Accessor Functions</h1>
<p>The <a class="el" href="SDOM_8hpp.html">SDOM.hpp</a> header may define a set of global functions within the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> namespace to provide convenient access to key framework components:</p><ul>
<li><span class="tt">getCore()</span></li>
<li><span class="tt">getStage()</span></li>
<li><span class="tt">getWindow()</span></li>
<li><span class="tt">getRenderer()</span></li>
<li>...etc.</li>
</ul>
<p>These global accessors allow users to retrieve singleton or shared instances of major subsystems without directly referencing their implementation details. This pattern simplifies initialization and integration, especially for scripting and cross-language bindings.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md29"></a>
Example Usage (with global accessor)</h2>
<div class="fragment"><div class="line">Core&amp; core = getCore();</div>
<div class="line">core.registerOnInit([]() {</div>
<div class="line">    <span class="comment">// Custom initialization</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line">core.registerOnQuit([]() {</div>
<div class="line">    <span class="comment">// Cleanup logic</span></div>
<div class="line">});</div>
<div class="line">core.registerOnUpdate([](<span class="keywordtype">float</span> dt) {</div>
<div class="line">    <span class="comment">// Game logic</span></div>
<div class="line">});</div>
<div class="line">core.registerOnEvent([](<span class="keyword">const</span> Event &amp;event) {</div>
<div class="line">    <span class="comment">// Handle events</span></div>
<div class="line">});</div>
<div class="line">core.registerOnRender([]() {</div>
<div class="line">    <span class="comment">// Render stage</span></div>
<div class="line">});</div>
<div class="line">core.registerOnUnitTest([]() {</div>
<div class="line">    <span class="comment">// Run tests</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    core.run();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md30"></a>
Composition Diagram</h1>
<div class="fragment"><div class="line"> -norender</div>
<div class="line">flowchart TB</div>
<div class="line">    classDef core fill:#eef7ff,stroke:#4a90e2,color:#1a3b5d,stroke-width:1px</div>
<div class="line">    classDef mod  fill:#f7fff0,stroke:#7bb661,color:#234d20,stroke-width:1px</div>
<div class="line">    classDef dep  fill:#f5f5f5,stroke:#999,color:#333,stroke-width:1px</div>
<div class="line"> </div>
<div class="line">    Core[&quot;Core (Singleton)\n- main loop\n- configure/run&quot;]:::core</div>
<div class="line">    Factory[&quot;Factory&quot;]:::mod</div>
<div class="line">    EventMgr[&quot;EventManager&quot;]:::mod</div>
<div class="line">    Stage[&quot;Stage (Root IDisplayObject)&quot;]:::mod</div>
<div class="line">    SDL[&quot;SDL Video Subsystem\n(window/renderer/texture)&quot;]:::dep</div>
<div class="line"> </div>
<div class="line">    Core --&gt; Factory</div>
<div class="line">    Core --&gt; EventMgr</div>
<div class="line">    Core --&gt; Stage</div>
<div class="line">    Core --&gt; SDL</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md31"></a>
Event Flow</h1>
<div class="fragment"><div class="line"> -norender</div>
<div class="line">sequenceDiagram</div>
<div class="line">  autonumber</div>
<div class="line">  participant Core as SDOM::Core</div>
<div class="line">  participant EM as EventManager</div>
<div class="line">  participant Stage as Stage (Root)</div>
<div class="line"> </div>
<div class="line">  Core-&gt;&gt;EM: poll/dispatch()</div>
<div class="line">  EM-&gt;&gt;Stage: propagate events\n(capture → target → bubble)</div>
</div><!-- fragment --><p>For details on propagation semantics, see <span class="tt"><a class="el" href="dom__propagation_8md.html">docs/dom_propagation.md</a></span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md32"></a>
Unit Tests</h1>
<p>Core exposes <span class="tt">onUnitTest()</span> and can route tests through objects that implement <span class="tt">IUnitTest</span>. Typically, Factory-managed objects (including Stages or specific components) provide focused tests invoked via Core’s test hook.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md33"></a>
Stage</h1>
<p>The Stage is the root <span class="tt">IDisplayObject</span>. It’s created via the Factory and orchestrated by Core. Child <span class="tt">IDisplayObject</span>s are attached under Stage; see also <span class="tt"><a class="el" href="architecture__overview_8md.html">docs/architecture_overview.md</a></span> for a full picture.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md34"></a>
SDOM Comprehensive Architecture Diagram</h1>
<p>For the complete library-wide diagram, see <span class="tt"><a class="el" href="architecture__overview_8md.html">docs/architecture_overview.md</a></span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md35"></a>
SDOM Event System Integration</h1>
<p>For event object shapes and propagation phases, see <span class="tt"><a class="el" href="dom__propagation_8md.html">docs/dom_propagation.md</a></span> and the Event/EventType API docs.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md36"></a>
Additional Interfaces and Utilities</h1>
<ul>
<li><span class="tt">IUnitTest</span>: lightweight interface for test hooks (see Unit Tests section).</li>
<li>Handles: <span class="tt">DomHandle</span> and <span class="tt">ResHandle</span> provide safe references to Factory-owned objects (see <span class="tt"><a class="el" href="object__handles_8md.html">docs/object_handles.md</a></span>).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md37"></a>
Extensibility &amp; Singleton Pattern</h1>
<p>The Core object is implemented as a singleton, ensuring a single point of control for the application's lifecycle, event management, and resource handling. Despite the singleton pattern, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> remains highly extensible:</p>
<ul>
<li>Hooks, eventListeners, and class-based inheritance allow users to customize behavior without modifying the Core implementation.</li>
<li>Plugins and modules can register their own callbacks or listeners with the singleton Core instance.</li>
<li>The singleton ensures global access and coordination, while extensibility is achieved through registration APIs and listener patterns.</li>
</ul>
<p>This design balances centralized control with flexible extension points for applications and language bindings.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md38"></a>
EventListener Support</h1>
<p>In addition to direct hook/callback registration, the Core framework can support external integration through eventListeners. This approach allows users to attach listener objects or functions to specific lifecycle and event types, enabling modular and decoupled handling of application events.</p>
<ul>
<li>Listeners can subscribe to events such as Init, Quit, Update, Render, and custom events.</li>
<li>The Core maintains a list of listeners for each event type and notifies them when the event occurs.</li>
<li>Listeners can be implemented as objects with event-handling methods, or as standalone functions.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md39"></a>
Example (C)</h2>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onInit() { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onQuit() { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onUpdate(<span class="keywordtype">float</span> dt) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onEvent(<span class="keyword">const</span> Event&amp; e) { <span class="comment">/* ... */</span> }</div>
<div class="line"><span class="keywordtype">void</span> onRender() { <span class="comment">/* ... */</span> }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    Core&amp; core = <a class="code hl_function" href="namespaceSDOM.html#a6b597fe37c57017a7139d0a4cdc84af6">SDOM::getCore</a>();</div>
<div class="line">    CoreConfig config;</div>
<div class="line">    config.windowWidth = 1280;</div>
<div class="line">    config.windowHeight = 960;</div>
<div class="line">    config.pixelWidth = 2.0;</div>
<div class="line">    config.pixelHeight = 2.0;</div>
<div class="line">    config.allowTextureResize = <span class="keyword">true</span>;</div>
<div class="line">    config.preserveAspectRatio = <span class="keyword">true</span>;</div>
<div class="line">    config.renderFlags = SDL_LOGICAL_PRESENTATION_LETTERBOX;</div>
<div class="line">    config.windowFlags = SDL_WINDOW_FULLSCREEN | SDL_WINDOW_RESIZABLE;</div>
<div class="line">    config.colorFormat = SDL_PIXELFORMAT_RGBA8888;</div>
<div class="line">    core.configure(config);</div>
<div class="line"> </div>
<div class="line">    core.addEventListener(EventType::Init, []() { onInit(); });</div>
<div class="line">    core.addEventListener(EventType::Quit, []() { onQuit(); });</div>
<div class="line">    core.addEventListener(EventType::Update, [](<span class="keywordtype">float</span> dt) { onUpdate(dt); });</div>
<div class="line">    core.addEventListener(EventType::Event, [](<span class="keyword">const</span> Event&amp; e) { onEvent(e); });</div>
<div class="line">    core.addEventListener(EventType::Render, []() { onRender(); });</div>
<div class="line"> </div>
<div class="line">    core.run();</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceSDOM_html_a6b597fe37c57017a7139d0a4cdc84af6"><div class="ttname"><a href="namespaceSDOM.html#a6b597fe37c57017a7139d0a4cdc84af6">SDOM::getCore</a></div><div class="ttdeci">Core &amp; getCore()</div><div class="ttdef"><b>Definition</b> SDOM_Utils.cpp:16</div></div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md40"></a>
Benefits</h2>
<ul>
<li>Enables multiple listeners for the same event type</li>
<li>Decouples event handling from the Core and main application logic</li>
<li>Facilitates plugin architectures and modular extensions</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md41"></a>
Registering Custom Stage Objects</h1>
<p>Custom Stage objects can be registered and managed through the Factory system, just like any other DOM object. To use a custom Stage:</p>
<ol type="1">
<li><b>Inherit from the Stage class to define your custom Stage type.</b></li>
<li><b>Register the custom Stage type with the Factory.</b></li>
<li><b>Create the Stage instance via the Factory.</b></li>
<li><b>Register the Stage with the Core using a unique name.</b></li>
<li><b>Switch to the custom Stage using <span class="tt">Core::setStage(name)</span>.</b></li>
</ol>
<p>This approach ensures consistent resource management and makes it easy to extend <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> with new scene types or behaviors.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md42"></a>
Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Register custom Stage type with Factory</span></div>
<div class="line">factory-&gt;registerType&lt;CustomStage&gt;(<span class="stringliteral">&quot;CustomStage&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a custom Stage instance</span></div>
<div class="line">resource_ptr&lt;Stage&gt; myStage = factory-&gt;create&lt;CustomStage&gt;(initStruct);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Register the Stage with Core</span></div>
<div class="line">core.registerStage(<span class="stringliteral">&quot;myCustomStage&quot;</span>, myStage);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Switch to the custom Stage</span></div>
<div class="line">core.setStage(<span class="stringliteral">&quot;myCustomStage&quot;</span>);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md43"></a>
Integration Methods Summary</h1>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> Core supports three primary methods for application setup and event handling:</p>
<ol type="1">
<li><b>Callback/Hook Registration</b><ul>
<li>Use <span class="tt">registerOnInit()</span>, <span class="tt">registerOnQuit()</span>, etc. to set function hooks for lifecycle and event methods.</li>
<li>Ideal for scripting languages, functional programming, and dynamic runtime configuration.</li>
</ul>
</li>
<li><b>EventListener Pattern</b><ul>
<li>Attach listener objects or functions to specific event types using <span class="tt">addEventListener()</span>.</li>
<li>Enables modular, decoupled event handling and plugin architectures.</li>
<li>Supports multiple listeners per event.</li>
</ul>
</li>
<li><b>Class-Based Inheritance</b><ul>
<li>Inherit from the Stage class and override virtual methods (<span class="tt">onInit()</span>, <span class="tt">onUpdate()</span>, etc.).</li>
<li>Familiar to C++ developers and suitable for static, strongly-typed applications.</li>
</ul>
</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md44"></a>
Flexibility &amp; Use Cases</h2>
<ul>
<li>Callback registration is best for cross-language bindings and dynamic configuration.</li>
<li>EventListeners are ideal for extensible, plugin-based systems.</li>
<li>Class-based inheritance provides a traditional OOP approach for C++ and similar languages.</li>
</ul>
<p>Applications can mix and match these methods as needed, ensuring <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> remains flexible and accessible to a wide range of development styles and languages.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md45"></a>
Performance Considerations</h1>
<ul>
<li>The difference in performance between the three setup types (callback registration, eventListeners, class-based inheritance) is generally negligible for most applications.</li>
<li><b>Direct callback/hook registration</b> is likely the fastest, as it involves a single function call per event and is well-suited for functional programming or C language bindings.</li>
<li><b>EventListener pattern</b> may introduce minor overhead if there are many listeners attached to the same event, as each must be iterated and invoked. This overhead is typically small unless the listener count is very high.</li>
<li><b>Class-based inheritance</b> performance is similar to direct callbacks, as virtual method dispatch is efficient in modern C++ compilers.</li>
</ul>
<p>For most use cases, the choice should be based on flexibility, language integration, and architectural needs rather than raw performance.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md46"></a>
Single Stage, Single Window Rationale</h1>
<p>A previous iteration of the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> API supported multiple windows and stages, but this introduced significant complexity:</p><ul>
<li>Each window/stage required separate initialization of external resources (bitmaps, fonts, etc).</li>
<li>Window placement is unreliable or unsupported on many OSes (e.g., Wayland, Windows).</li>
<li>Managing multiple renderers and resource lifetimes increases maintenance burden.</li>
</ul>
<p>For these reasons, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> now uses a single stage, single window framework. SDL window/renderer/texture management is encapsulated within the Core object, ensuring centralized control and simplified resource management.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md47"></a>
Overriding the Default Stage</h1>
<p>If a user defines multiple Stage objects or wishes to override the default stage:</p><ul>
<li>The Core should maintain a single active Stage instance at any time.</li>
<li>When a new Stage is set, the previous (default) Stage should be destroyed or dereferenced, and all rendering/event logic should be redirected to the new Stage.</li>
<li>The API should provide a method such as <span class="tt">setStage(Stage*)</span> or <span class="tt">replaceStage(Stage*)</span> to handle this transition cleanly.</li>
<li>Only one Stage should be active and connected to the window/renderer at a time; additional Stage objects should remain inactive until explicitly set as the current stage.</li>
</ul>
<p>This approach maintains the simplicity and reliability of the single stage/single window model, while allowing advanced users to swap or override the Stage if needed.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md48"></a>
Multiple Stages as Scenes</h1>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> can support multiple Stage objects, but only one Stage is active at any given time. This enables a flexible scene management system:</p><ul>
<li>Each Stage instance can represent a different "Scene" (e.g., menu, gameplay, pause screen).</li>
<li>The Core maintains a reference to the currently active Stage.</li>
<li>Users can create, store, and switch between Stage objects using an API such as <span class="tt">setActiveStage(Stage*)</span> or <span class="tt">activateScene(Stage*)</span>.</li>
<li>When a new Stage is activated, the previous Stage is deactivated (but not destroyed), allowing for fast scene transitions and state preservation.</li>
<li>All rendering, event handling, and updates are directed to the active Stage.</li>
</ul>
<p>This approach combines the simplicity of a single window with the flexibility of multi-scene applications, making <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> suitable for games, interactive apps, and complex UIs.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md49"></a>
Window Resizing &amp; Texture Resolution</h1>
<p>Window resizing introduces several design considerations, especially when supporting multiple stages or scenes with their own textures and renderers:</p>
<ul>
<li><b>Texture Resolution Adjustment:</b> <br  />
 When the window is resized, you can choose to:<ul>
<li>Dynamically recreate the render target texture to match the new window size (may require reloading or scaling assets).</li>
<li>Keep the texture resolution fixed and scale/stretch the rendered output to fit the window.</li>
</ul>
</li>
<li><b>Rendering Strategies:</b> <br  />
<ul>
<li><b>Stretch:</b> Scale the rendered texture to fill the window, which may distort aspect ratio.</li>
<li><b>Letterbox/Pillarbox:</b> Maintain aspect ratio by adding black bars (letterboxing) if the window size does not match the texture resolution.</li>
<li><b>Dynamic Layout:</b> Adjust DOM display objects and UI layout to fit the new window size, which may require recalculating positions and sizes.</li>
</ul>
</li>
<li><b>Complexity with Multiple Stages:</b> <br  />
 If each Stage has its own texture and renderer, resizing the window means:<ul>
<li>The active Stage must update its renderer and texture to match the new window size.</li>
<li>Inactive Stages may need to store their preferred resolution and update when activated.</li>
<li>DOM display objects must be aware of the current renderer and texture, and may need to adjust their layout or assets accordingly.</li>
</ul>
</li>
<li><b>Recommended Approach:</b> <br  />
<ul>
<li>Compose the SDL Video Subsystem within the Core object for centralized management.</li>
<li>Provide hooks/callbacks (e.g., <span class="tt">onWindowResize(int width, int height)</span>) for Stages and DOM objects to respond to window size changes.</li>
<li>Decide on a default rendering strategy (stretch, letterbox, dynamic layout) and allow applications to override as needed.</li>
<li>Document the implications of window resizing for asset management, texture recreation, and UI layout.</li>
</ul>
</li>
</ul>
<p>This approach balances centralized control with flexibility, ensuring that window resizing is handled consistently and efficiently across all stages and display objects.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md50"></a>
Shared Display Texture for Stages</h1>
<p>While <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> supports multiple Stage objects for scene management, it is not necessary for each Stage to maintain its own main display texture. If all Stages share the same pixel dimensions as the main display managed by Core, they can simply use the same CoreTexture for rendering.</p>
<ul>
<li>This approach reduces memory usage and simplifies resource management.</li>
<li>All Stages render to the same texture, ensuring consistent output and easy scene transitions.</li>
<li>If a Stage requires offscreen rendering or special effects, it can create its own auxiliary textures as needed, but the main display texture remains shared.</li>
</ul>
<p>By default, <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> encourages sharing the CoreTexture among all Stages unless an application has specific requirements for unique render targets per scene.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md51"></a>
Stages as Game States or Modes</h1>
<p>Supporting multiple Stage objects in <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> enables the framework to represent different states or modes within an application or game. For example:</p>
<ul>
<li><b>Main Menu Stage:</b> Handles menu navigation, UI, and input for starting or exiting the game.</li>
<li><b>Settings Stage:</b> Manages configuration options, audio/video settings, and user preferences.</li>
<li><b>Gameplay Stage:</b> Contains the main game logic, rendering, and event handling for active play.</li>
<li><b>Pause Stage:</b> Displays pause menu, overlays, or temporary dialogs during gameplay.</li>
</ul>
<p>Each Stage encapsulates its own display hierarchy, event handling, and logic, allowing for clean separation of concerns and easy transitions between states. The Core manages which Stage is currently active, enabling fast and reliable switching between modes.</p>
<p>This design makes <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> well-suited for games and interactive applications that require multiple distinct states or scenes.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md52"></a>
Changing the Active Stage</h1>
<p><a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> provides a simple API for switching the active Stage (scene) by name:</p>
<div class="fragment"><div class="line">Core::setStage(std::string name);</div>
</div><!-- fragment --><ul>
<li>This call sets the Stage identified by its unique name as the active scene.</li>
<li>All rendering, event handling, and updates are redirected to the newly activated Stage.</li>
<li>The previous Stage is deactivated but remains available for future use or state preservation.</li>
<li>This approach enables fast and reliable scene transitions, making it easy to implement menus, gameplay, settings, and other modes.</li>
</ul>
<p>Example usage: </p><div class="fragment"><div class="line">Core&amp; core = <a class="code hl_function" href="namespaceSDOM.html#a6b597fe37c57017a7139d0a4cdc84af6">SDOM::getCore</a>();</div>
<div class="line">core.setStage(<span class="stringliteral">&quot;gameplay&quot;</span>); <span class="comment">// Switch to the gameplay scene</span></div>
</div><!-- fragment --><p>This API keeps scene management simple and intuitive for developers.</p>
<hr  />
<p> This document will be expanded as the <a class="el" href="namespaceSDOM.html" title="Contains all core classes and utilities for the SDOM library.">SDOM</a> Core framework evolves. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<footer>
  <a href="#top">Back to top</a> &nbsp;|&nbsp; <a href="https://github.com/warte67/SDOM">Back to SDOM on GitHub</a>
</footer>
