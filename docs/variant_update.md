# SDOM Variant Dynamic Design & Status

Last updated: 2025-12-11

This document is the working design note for the SDOM `Variant` system across the C++ API, the C ABI, and the in-progress scripting bindings. It consolidates what exists in the tree today, highlights the gaps, and captures the TODOs required to finish the feature set (C++ ‚úÖ, C ABI üöß, Lua üöß).

---

## 1. Current State Overview

### 1.1 Architectural Role

- **Dynamic data core:** `Variant` is the single runtime container that carries event payloads, object properties, registry snapshots, JSON round-trips, and (eventually) Lua-visible data (`include/SDOM/SDOM_Variant.hpp:65-215`). It can hold primitives, arrays, objects, dynamic shared_ptr payloads, display/asset handles, and non-owning `Event*` pointers.
- **Shared-node storage:** Containers store `std::shared_ptr<Variant>` entries so copies are cheap and mutations preserve aliasing semantics (`include/SDOM/SDOM_Variant.hpp:101-134`).
- **Path navigation:** Dotted/bracket path helpers (`parsePath`, `getPath`, `setPath`, `pathExists`, `erasePath`) provide deterministic traversal with creation options and descriptive error messages (`src/SDOM_Variant.cpp:57-150` and `src/SDOM_Variant.cpp:986-1156`).
- **JSON integration:** `toJson` / `fromJson` support depth guards, NaN/Inf controls, and unsigned handling (`src/SDOM_Variant.cpp:1160-1326`).
- **Reflection hook:** `Variant::registerBindings` seeds the `DataRegistry` so the bind generator can emit the ABI view and attach callable metadata (`src/SDOM_Variant.cpp:536-666`).
- **Documentation:** `docs/Variant.md` (usage examples) and `docs/extensible_variant.md` (full design spec) remain the long-form references for converter usage and reflection strategy.

### 1.2 Implementation Snapshot

#### C++ Core (shipping)

- **Type coverage:** Constructors exist for all primitive, container, handle, and event shapes plus helpers like `makeArray`, `makeObject`, and dynamic factories (`include/SDOM/SDOM_Variant.hpp:138-218`).
- **Dynamic registry:** `Variant::ConverterEntry` currently supports JSON serialization (`toJson`) and deserialization (`fromVariant`). This registry is wired through `VariantRegistry` for both type_index and name lookups (`include/SDOM/SDOM_Variant.hpp:232-365`).
- **Path semantics:** `getPathImpl` guards against scalar traversal and surfaces uniform error strings (`src/SDOM_Variant.cpp:57-150`). Public wrappers convert strings into `PathView`, set `CoreAPI` error state, and mirror `setPath` creation rules (`src/SDOM_Variant.cpp:986-1109`).
- **Core integration:** Variant-backed handles and events are used throughout the `_V` C++ helpers (Core focus/setters, display/asset lookups, etc.) exposed via `Core::capi*` (`src/SDOM_CoreAPI.cpp:2514-2960`, `src/SDOM_CoreAPI.cpp:4428-5143`) and `Event` payload helpers (`src/SDOM_Event.cpp:81-215`, `src/SDOM_Event.cpp:941-1019`).
- **Unit tests:** `examples/test/src/Variant_UnitTests.cpp` covers converters, JSON, VariantView, and error semantics. `examples/test/src/Event_CAPI_UnitTests.cpp` and `examples/test/src/Core_UnitTests.cpp` exercise the `_V` helpers indirectly.

#### ABI Surface & Hand Authored C API

- **Struct view:** `include/SDOM/CAPI/SDOM_CAPI_Variant.h` defines a provisional ABI struct (`type`, reserved bytes, `flags`, `uint64_t data`) plus scalar helpers (`SDOM_Type`, `SDOM_Is*`, `SDOM_As*`, `SDOM_Make*`) and path helpers (`*_GetPath`, `*_SetPath`, `*_PathExists`, `*_ErasePath`).
- **Implementation:** `src/SDOM_Variant.cpp:285-528` contains the real C entry points. Import/export helpers translate between the struct and the C++ object, with thread_local scratch buffers for strings/containers (`s_variantStringScratch`, `s_variantValueScratch`). Path helpers convert to C++ `Variant`, invoke the C++ method, then marshal back.
- **Handle helpers:** `include/SDOM/CAPI/SDOM_CAPI_Handles.h` and `src/SDOM_Variant.cpp:394-466` expose `SDOM_MakeDisplayHandle`, `SDOM_MakeAssetHandle`, and tag guards (`SDOM_Handle_Is*`, `SDOM_Handle_ObjectId`, `SDOM_Handle_IsValid`).
- **Testing:** `examples/test/src/Variant_CAPI_UnitTests.cpp` drives the C API against borrowed `Variant` nodes (see `borrow_variant` at lines 20-41) to validate success and error strings for `GetPath` and friends.

#### Generator Outputs & Autogenerated Shims

- **Binding manifest:** `Variant::registerBindings` registers every function; the bind generator emits the header plus autogenerated invokers (`src/CAPI/SDOM_CAPI_BindGenerator.cpp:418-666`).
- **Autogenerated C wrappers:** `src/CAPI/SDOM_CAPI_Variant.cpp` mirrors every function but currently returns placeholder structs for the `SDOM_Make*` family (TODO markers at lines 115-156) and routes everything via `SDOM::CAPI::invokeCallable`. These stubs coexist with the hand-authored implementations in `src/SDOM_Variant.cpp`, so only one set should remain once marshalling is complete.

---

## 2. Design Intent & Behavioral Contracts

### Variant Aliasing Semantics

- C++ Variants intentionally share nodes via `std::shared_ptr` so copies of arrays/objects remain views of the same backing graph until a mutation occurs. This mirrors a *copy-on-write* style reference semantics useful for engine-side reflection and avoids accidental deep copies while traversing properties.
- Cross-language boundaries (C API, Lua, JSON) must never expose shared pointers directly. When exporting to C, JSON, or Lua the expectation is **copy-by-value** semantics so that scripts and foreign callers cannot mutate engine-owned graphs inadvertently.
- Internally we continue to treat aliasing as desirable for read-mostly structures (registry snapshots, event payload defaults). Any API that promises independent ownership (`Variant::clone`, future `SDOM_Variant_Copy`) must deep-copy the reachable graph.

### ABI Representation: Current vs Final

- **Current:** A 16-byte POD (`type/reserved/flags/data`) is passed by value. Composite or dynamic values sneak pointers into `data` and rely on thread_local scratch, so lifetime lasts only until the next call.
- **Transition state:** Both manually implemented functions (`src/SDOM_Variant.cpp`) and generated wrappers (`src/CAPI/SDOM_CAPI_Variant.cpp`) exist, with the latter still missing return marshalling. This duality will continue until the generator can emit correct code or call into the manual helpers.
- **Final intent:** Replace raw POD-only semantics with either (a) an opaque ref-counted handle (`SDOM_VariantHandle*`) that owns a heap `Variant`, or (b) a hybrid model where scalars stay inline but arrays/objects own heap storage via an opaque pointer. In both cases, thread_local scratch must disappear and callers must be able to free values deterministically.

### Dynamic Registry Responsibilities

- `Variant::registerConverter<T>()` is the canonical entry point for registering converters. Registration is expected to happen during static initialization or subsystem startup before cross-language data flows. The registry stores converters keyed by both `type_index` and human-readable names.
- Access is guarded by a shared mutex inside `VariantRegistry`; registration and lookup are thread-safe but we still recommend registering converters once at startup to avoid contention.
- Converters are long-lived (effectively static) and must not capture transient state. The registry is the foundation for JSON serialization today and will back Lua/native conversions and C ABI marshaling in the future.

### Path Semantics Guarantees

- `getPath`/`pathExists` are *pure:* they never mutate containers, never allocate intermediates, and never set global errors unless parsing fails. They are safe to call repeatedly inside hot loops.
- `setPath`/`erasePath` obey `PathOptions`. By default they auto-create missing **objects** but not arrays. When `extend_arrays_with_null` is enabled the helper will append null entries until the requested index exists.
- Error reporting is deterministic: parse errors win first, then type-mismatch errors (e.g., ‚ÄúExpected object for field access‚Äù), followed by traversal failures (‚ÄúPath not found‚Äù) and finally scalar traversal guards (‚ÄúCannot traverse into scalar type‚Äù). This ordering mirrors the messages in `getPathImpl`.

### Event Payload Ownership & Mutability

- Events store payload Variants by value when authored in C++ (`Event::setPayloadValueVariant`). Once dispatched, listeners receive **copies** of the payload to avoid surprising cross-listener mutations.
- Event Variants may contain handle references or non-owning `Event*` pointers; the contract is that handles remain valid for the duration of the dispatch, but `Event*` entries are read-only views and must not be stored past dispatch.
- When C/Lua listeners need to mutate payloads, they must clone the incoming Variant and store their own copy; engine-managed payloads are considered immutable once the dispatch begins.

### Lua Conversion Model (forward-looking)

- The Lua bridge will reintroduce `Variant::toLua` / `Variant::fromLuaObject`. Tables with contiguous integer keys map to Variant arrays; other tables map to Variant objects. Ambiguous tables (mixed numeric/string keys) preserve every entry in an object.
- Lua userdata will either map to Variant dynamic values (when a converter exists) or error out. Metatables are ignored unless a converter explicitly inspects them.
- `Variant::TableStorageMode` will control whether tables are deep-copied (default) or stored as opaque Lua references. Copy-by-value is required when passing data outside the Lua VM.

### Thread-Safety Expectations

- The **final** C API must be safe to call concurrently from multiple threads. Today‚Äôs implementation is *not* thread-safe because it relies on shared thread_local buffers that can be invalidated if a thread re-enters the API.
- Target behavior: all exported functions should operate on caller-owned handles or copies, avoid global mutable state beyond the documented `SDOM_GetError()` string, and never reuse buffers across calls. Global locks are acceptable initially; the long-term goal is lock-free read operations.

### Performance Considerations

- Variant copies are cheap for scalars but can churn shared_ptr allocations for nested objects. Hot paths (per-frame updates, physics callbacks) should either avoid Variants or reuse them via pools.
- Path parsing allocates; callers that repeatedly access the same path should pre-parse via `parsePath` and call the `PathView` overloads.
- JSON serialization is intentionally defensive (depth guards, NaN handling). For bulk serialization, prefer streaming serializers or purpose-built structs instead of round-tripping through Variant.

### Unsupported Use Cases

- Variants are **not** intended to store large binary blobs, megabyte-scale arrays, or per-frame transient values. Use specialized asset or ECS data for those cases.
- They are not a replacement for strongly typed ECS/component storage, shader uniforms, or physics state; Variants should remain at the configuration, event, and scripting boundaries.
- Avoid mutating the same Variant graph from multiple threads; copy the Variant and mutate each copy independently.

---
## 3. Gaps & Known Issues

1. **Non-owning ABI representation:** Arrays, objects, and dynamic values rely on `s_variantValueScratch` (`src/SDOM_Variant.cpp:327-341`). Calls such as `SDOM_Variant_GetPath` return pointers into thread_local storage, so copies become invalid after the next call and no API exists to copy or free them.
2. **No creation/destruction API:** The C surface only exposes inline `SDOM_Make*` constructors that pack data into the `SDOM_Variant` POD. There is no allocation API (`SDOM_Variant_CreateObject`, `SDOM_Variant_Free`, etc.), so C callers cannot materialize containers without piggybacking on the borrowed-pointer trick used by the unit tests.
3. **Autogenerated wrapper drift:** `src/CAPI/SDOM_CAPI_Variant.cpp` still contains TODOs for return-type marshalling and duplicates the manually implemented functions. This divergence risks ABI mismatches once the generator output is wired into the build.
4. **String lifetime:** `SDOM_MakeCString` and `exportVariantToC` store raw pointers with no ownership guarantees (`src/SDOM_Variant.cpp:305-309`, `src/SDOM_Variant.cpp:389-391`). Cross-language callers cannot safely hold on to strings beyond the immediate call.
5. **Path mutator guarantees:** `SDOM_Variant_SetPath` wraps the C++ `setPath` but the C API cannot currently pass `PathOptions` (create intermediates, extend arrays). The default C++ behavior creates objects but not arrays unless options are set; callers cannot toggle that behavior through the C layer today.
6. **Incomplete error surfacing:** Scalar accessors (`SDOM_AsBool`, `SDOM_AsInt`, `SDOM_AsFloat`, `SDOM_AsString`) silently coerce or return defaults without setting `SDOM_GetError()` when the type mismatches (`src/SDOM_Variant.cpp:463-489`). This differs from the documented ‚Äúclear error on failure‚Äù model.
7. **Lua bridge removed:** `Variant::ConverterEntry` no longer exposes Lua conversion hooks (only JSON) and there are no `Variant::toLua` / `fromLuaObject` helpers in the current header (`include/SDOM/SDOM_Variant.hpp`). The existing docs (`docs/Variant.md`) still mention Lua converters, so the implementation and documentation have drifted.
8. **Docs for C API missing:** `docs/Variant_CAPI.md` (referenced in older plans) does not exist; the best we currently have is this document plus `docs/migration_variants.md`.
9. **Testing gaps:** Existing C API unit tests never exercise object mutation, `SetPath` intermediate creation, handle validation, or multi-threaded access. They also depend on `borrow_variant`, which sidesteps the lack of creation APIs (`examples/test/src/Variant_CAPI_UnitTests.cpp:20-42`).
10. **Lua-facing bindings waiting:** Lua still invokes POD-based Core APIs; `_V` siblings exist (`include/SDOM/CAPI/SDOM_CAPI_Core.h:711-1359`, `include/SDOM/CAPI/SDOM_CAPI_Event.h:254-664`) but the Lua scaffolding in `lua/api_stubs.lua` has not migrated to Variants.

---

## 4. Migration Path (toward ‚Äú100% done‚Äù)

### A. C++ Core Completion

1. **Reintroduce Lua converters:** Extend `Variant::ConverterEntry` with `toLua` / `fromLua` hooks and provide `Variant::toLua` / `Variant::fromLuaObject` implementations guarded by `SDOM_HAS_LUA`. Update `docs/Variant.md` and `docs/extensible_variant.md` accordingly.
2. **Finalize `VariantStorage` ABI metadata:** Document the thread-safety guarantees for `Vari antStorage::Array/Object` and ensure mutation helpers (`push`, `set`) remain exception-safe and analyzer-clean once Lua support returns.
3. **Event/handle helpers audit:** Confirm that `DisplayHandle` and `AssetHandle` factories handle null factories gracefully and expose any necessary diagnostic telemetry (`src/SDOM_Variant.cpp:178-210`).

### B. ABI & C API Work

1. **Stable allocation API:** Introduce owned `SDOM_VariantHandle` objects plus `SDOM_Variant_Create*` / `SDOM_Variant_Free` functions that wrap heap-allocated `Variant` objects instead of encoding pointers in the inline struct. Document ownership and lifetime rules.
2. **Container mutation helpers:** Add `SDOM_Variant_ObjectSet`, `_ObjectRemove`, `_ArrayAppend`, `_ArraySetAt`, `_ArrayRemoveAt`, and `_Snapshot` helpers so C callers can build nested structures without touching C++ internals.
3. **Path options exposure:** Extend the C API with `SDOM_PathOptions` flags or dedicated create/extend parameters so callers can opt into the same semantics available through `PathOptions` (`include/SDOM/SDOM_Variant.hpp:34-48`).
4. **Return marshalling in generated wrappers:** Teach the bind generator how to marshal `SDOM_Variant` return values (mirroring the hand-written implementations) and delete the duplicated code in `src/SDOM_Variant.cpp` or, alternatively, teach the generator to call those implementations directly.
5. **String/data ownership:** Replace the thread_local scratch approach with reference-counted buffers or out-parameters (e.g., `SDOM_Variant_StringView` that must be copied before the next call). Update docs/tests to reflect the new contract.
6. **Error consistency:** Make every scalar getter/constructor honor the documented rule: return `false` and set `SDOM_GetError()` when the type mismatches; leave `SDOM_GetError()` untouched on success (`include/SDOM/CAPI/SDOM_CAPI_Core.h:56-65` provides the error channel).
7. **Handles & events from C:** Provide `SDOM_DisplayHandle_FromVariant`, `SDOM_AssetHandle_FromVariant`, and `SDOM_Event_FromVariant` helpers that copy out POD structs, mirroring `SDOM_Event_FromVariant` (`include/SDOM/CAPI/SDOM_CAPI_Event.h:658-664`) but for asset/display handles.
8. **Manifest & generator alignment:** Update `src/CAPI/bindings_manifest.json` so the generator knows about any new entry points, regenerate headers, and ensure `SDOM_CAPI_BindGenerator` emits deterministic ordering.

### C. Tooling & Tests

1. **Unit tests for new APIs:** Add C API tests that create and mutate objects/arrays purely through the new helpers, assert deep equality after round-tripping back into C++, and validate error messages for mismatched operations.
2. **Thread-safety checks:** Add multi-threaded smoke tests that concurrently export Variants to the C API to ensure the new ownership model is safe (the current scratch-buffer implementation is not).
3. **Regression tests for `_V` Core APIs:** Expand `examples/test/src/Core_UnitTests.cpp` to ensure every POD API has an equivalent `_V` path and both stay in sync.

### D. Documentation & Bindings

1. **C API guide:** Author `docs/Variant_CAPI.md` with creation/mutation examples, ownership tables, and error-handling guidance. Link it from `README.md` and `docs/migration_variants.md`.
2. **Docs sync:** Update `docs/Variant.md` so it matches the current C++ feature set (remove stale Lua snippets until the Lua bridge is restored) and reference this document for ABI details.
3. **Lua migration:** Once the ABI is stable, move the Lua bindings over to `_V` functions. Provide helper shims in `lua/api_stubs.lua` that call the new C API, and add Lua tests that exercise Variant-based data exchange.
4. **Deprecation notice:** When bindings migrate, mark the POD-only C APIs as legacy in the generated docs and set a removal checklist (per `docs/migration_variants.md`).

---

## 5. Concrete Step-by-Step Checklist

1. **‚òê Stabilize the ABI surface**
   - ‚òê Decide on the owned handle representation for `SDOM_Variant` (inline POD vs opaque handle) and update `include/SDOM/CAPI/SDOM_CAPI_Variant.h`.
   - ‚òê Implement `SDOM_Variant_CreateNull/Object/Array/String/Int/Float/Handle` plus `SDOM_Variant_Free` in `src/SDOM_Variant.cpp`; document ownership semantics.
   - ‚òê Replace thread_local scratch usage (`s_variantStringScratch`, `s_variantValueScratch`) with safe buffers or copy-out mechanisms.
2. **‚òê Expand mutation/query helpers**
   - ‚òê Add object helpers (`SDOM_Variant_ObjectSet`, `_ObjectRemove`, `_ObjectGet`) and array helpers (`_ArrayAppend`, `_ArraySetAt`, `_ArrayRemoveAt`).
   - ‚òê Expose `SDOM_PathOptions` flags so `SetPath` mirrors all C++ behaviors; update both header and implementation.
   - ‚òê Ensure scalar getters (`SDOM_As*`) and new helpers set `SDOM_GetError()` on misuse and leave it untouched on success.
3. **‚òê Align generator output**
   - ‚òê Update `src/CAPI/bindings_manifest.json` and `SDOM_CAPI_BindGenerator` so generated code marshals `SDOM_Variant` returns correctly.
   - ‚òê Regenerate headers/sources, reconcile them with the hand-written implementations, and remove duplicate code paths.
4. **‚òê Reintroduce Lua bridge**
   - ‚òê Re-add `Variant::toLua`, `Variant::fromLuaObject`, and the corresponding converter hooks guarded by `SDOM_HAS_LUA`.
   - ‚òê Sync `docs/Variant.md` and `docs/extensible_variant.md` to the restored behavior and add Lua conversion tests.
5. **‚òê Testing & validation**
   - ‚òê Extend `examples/test/src/Variant_CAPI_UnitTests.cpp` to use the new creation/mutation APIs exclusively.
   - ‚òê Add regression tests for `_V` Core/Event paths to ensure POD and Variant variants stay in lockstep.
   - ‚òê Run multithreaded stress tests (or sanitizers) to confirm the new ownership model is thread-safe.
6. **‚òê Documentation & bindings rollout**
   - ‚òê Write `docs/Variant_CAPI.md` with practical samples and troubleshooting notes; link it from README/migration guide.
   - ‚òê Update Lua bindings (`lua/api_stubs.lua`) to route through `_V` APIs; add Lua tests once the ABI is solid.
   - ‚òê Announce the deprecation timeline for POD-only APIs and track removal readiness via `docs/migration_variants.md`.

---

## 6. Snapshot Summary

- ‚úÖ C++ `Variant` implementation is feature-complete for core engine needs, with JSON/path/dynamic support and integration across Core/Event subsystems.
- ‚úÖ `_V` variants of the Core and Event C APIs exist and are exercised by unit tests.
- üöß ABI helpers still expose a provisional 16-byte struct without ownership, creation, or container mutation helpers.
- üöß Autogenerated C wrappers are partially stubbed (`TODO` return marshalling), and documentation for the C API is missing.
- üöß Lua bindings have not yet been connected to the Variant pipeline; docs still describe the pre-refactor behavior.

Finishing the TODOs above will give SDOM a stable, script-friendly Variant surface that matches the intent laid out in `docs/extensible_variant.md` and enables future Lua (and other language) bindings to rely on a single, well-documented data model.
