#!/usr/bin/env bash
# update_latest_anchor.sh
# -------------------------------------------------------------
# Automatically moves or creates the <a id="latest-update"></a>
# anchor in docs/progress.md so it appears immediately above the
# most recent daily heading (e.g., "## üóìÔ∏è November 4, 2025").
#
# If no entry exists for today, this script will automatically
# insert a new daily heading along with a starter progress
# template below it, ready for editing.
#
# Run this at the start of each new day before logging progress.
#
# Example anchors inserted:
#   <a id="november-9-2025"></a>
#   <a id="latest-update"></a>
# -------------------------------------------------------------

set -euo pipefail

PROG_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
REPO_ROOT=$(cd -- "${PROG_DIR}/.." && pwd)
FILE="${REPO_ROOT}/docs/progress.md"

if [[ ! -f "${FILE}" ]]; then
  echo "[update_latest_anchor] File not found: ${FILE}" >&2
  exit 0
fi

tmp_out=$(mktemp)

# Support a dry-run mode so users can preview changes without touching files
DRYRUN=0
if [[ "${1:-}" == "--dry-run" || "${SDOM_DRY_RUN:-}" == "1" ]]; then
  DRYRUN=1
fi
# First, remove any existing <a id="latest-update"></a> occurrences and
#strip a preceding date anchor if it's immediately before the latest-update
#anchor. This avoids leaving stale anchors in the file when the AWK
#insertion logic runs.
clean_file=$(mktemp)
awk '
  BEGIN { date_anchor_re = "^<a id=\"[a-z]+-[0-9]{1,2}-[0-9]{4}\"></a>$"; latest_re = "^<a id=\"latest-update\"></a>$" }
  {
    lines[NR] = $0
  }
  END {
    for (i = 1; i <= NR; ++i) {
      if (lines[i] ~ latest_re) {
        # If previous line is a date anchor, remove that anchor but preserve a blank line
        if (i > 1 && lines[i-1] ~ date_anchor_re) {
          lines[i-1] = "";
        }
        # Remove the latest-update line (leave a blank line in its place)
        lines[i] = "";
      }
    }
    for (i = 1; i <= NR; ++i) print lines[i]
  }
' "${FILE}" >"${clean_file}"

# Use the cleaned file as the input for the AWK transformation below
FILE_CLEANED="${clean_file}"

# Allow override for testing (e.g., SDOM_TODAY="November 1, 2025")
if [[ -n "${SDOM_TODAY:-}" ]]; then
  TODAY="$SDOM_TODAY"
else
  TODAY=$(date '+%B %-d, %Y' 2>/dev/null || date '+%B %e, %Y')
fi

# Anchor ID (lowercase, hyphenated date) for linkability
DATE_ID=$(LC_ALL=C echo "$TODAY" \
  | tr '[:upper:]' '[:lower:]' \
  | sed 's/,//g; s/[[:space:]]\+/-/g')

# Normalize spacing (handles double-space in some locales)
TODAY=$(echo "$TODAY" | sed 's/  / /g')

awk -v TODAY="$TODAY" -v DATE_ID="$DATE_ID" '
  BEGIN {
    months = "January|February|March|April|May|June|July|August|September|October|November|December"
    heading_re = "^##[[:space:]]+.*(" months ") [0-9]{1,2}, [0-9]{4}"
    last_idx = 0
    out_n = 0
    today_idx = 0
    eod_idx = 0
    date_anchor_re = "^<a id=\"[a-z]+-[0-9]{1,2}-[0-9]{4}\"></a>$"
    pending_date_anchor = ""
  }

  {
    # Capture the last date anchor encountered so we can drop it alongside the latest-update anchor
    if ($0 ~ date_anchor_re) {
      pending_date_anchor = $0
      next
    }

    if ($0 ~ /^<a id="latest-update"><\/a>$/) {
      pending_date_anchor = ""
      next
    }

    if (pending_date_anchor != "") {
      out_n++
      lines[out_n] = pending_date_anchor
      if (pending_date_anchor ~ date_anchor_re) pending_date_anchor = ""
    }

    out_n++
    lines[out_n] = $0

    if ($0 ~ heading_re) last_idx = out_n
    if ($0 ~ /^<a id="end-of-day"><\/a>$/ || $0 ~ /^####[[:space:]]+end-of-day(.*)$/) eod_idx = out_n
    if ($0 ~ /^##[[:space:]]+/ && index($0, TODAY) > 0) today_idx = out_n
  }

  END {
    # Fallback: catch older date heading formats
    if (last_idx == 0) {
      for (i = 1; i <= out_n; i++) {
        if (lines[i] ~ /^###[[:space:]]*\[[A-Za-z]+ [0-9]{1,2}, [0-9]{4}\]/)
          last_idx = i
      }
    }

    if (pending_date_anchor != "") {
      out_n++
      lines[out_n] = pending_date_anchor
      pending_date_anchor = ""
    }

    insert_anchor_at = 0
    insert_new_heading = 0
    new_heading_line = ""

    if (today_idx > 0) {
      insert_anchor_at = today_idx
    } else if (eod_idx > 0) {
      insert_anchor_at = eod_idx + 1  # ensure new block appears AFTER last day‚Äôs terminator
      insert_new_heading = 1
      new_heading_line = "## üóìÔ∏è " TODAY " ‚Äî [Title Placeholder]"
    } else if (last_idx > 0) {
      insert_anchor_at = last_idx
    } else {
      for (i = 1; i <= out_n; i++) print lines[i]
      exit 0
    }

    # Markdown template for new daily section
    template_block = "> üí¨ *[Brief summary of today‚Äôs focus or achievements.]*\n\n" \
         "### üß© [Subsystem or Feature Group]\n" \
         "- [Key change or feature accomplished.]\n" \
         "- [Supporting details, design notes, or rationale.]\n\n" \
         "### üåü **Summary:**\n" \
         "_[Short summary of results and next direction.]_\n\n" \
         "**üöß ToDo Today**\n" \
         "- ‚òê [Task 1]\n" \
         "- ‚òê [Task 2]\n\n" \
         "#### ü§î *End of Day Reflection*\n" \
         "> *\"_reflechion quote\"*\n\n" \
         "---\n\n" \

    backlink_line = "[‚¨ÜÔ∏è Back to Progress Updates](../progress.md#progress-updates)"

    for (i = 1; i <= out_n; i++) {
      if (i == insert_anchor_at) {
        print "<a id=\"" DATE_ID "\"></a>"
        print "<a id=\"latest-update\"></a>"

        if (insert_new_heading) {
          # Add blank line separation if not already present
          if (out_n > 0 && lines[out_n] !~ /^$/) print ""
          
          print new_heading_line
          print ""

          # Only insert the full template if file does NOT already end with "end-of-day"
          if (lines[out_n] !~ /^####[[:space:]]+end-of-day(.*)$/) {
            print template_block
            print backlink_line
          } else {
            # Avoid duplicate terminators
            print "_[Brief summary of today‚Äôs focus or achievements.]_"
            print ""
            print backlink_line
          }

          # Ensure the end-of-day marker appears immediately after the backlink
          print "#### end-of-day"
        }
      }

      # Skip any existing end-of-day markers to avoid duplicates; we append a single marker above
      if (lines[i] ~ /^####[[:space:]]+end-of-day(.*)$/) {
        continue
      }

      print lines[i]
    }
  }
 ' "${FILE_CLEANED}" >"${tmp_out}"

# remove temporary cleaned input
rm -f "${clean_file}"

# Only update file if there are changes
if cmp -s "${FILE}" "${tmp_out}"; then
  rm -f "${tmp_out}"
  echo "[‚úì] Progress log up-to-date (no changes)"
else
  if [[ ${DRYRUN} -eq 1 ]]; then
    echo "[--dry-run] Preview of changes (diff):"
    diff -u "${FILE}" "${tmp_out}" || true
    rm -f "${tmp_out}"
    rm -f "${clean_file}"
    exit 0
  fi

  mode=$(stat -c '%a' "${FILE}")
  install -m "${mode}" "${tmp_out}" "${FILE}"
  rm -f "${tmp_out}"
  rm -f "${clean_file}"
  echo "[update_latest_anchor] Updated: ${FILE}"
  echo "[update_latest_anchor] Anchors inserted: <${DATE_ID}> and <latest-update>"
fi
